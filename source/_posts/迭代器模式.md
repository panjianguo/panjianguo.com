---
title: 迭代器模式
date: 2018-02-05 20:25:44
tags:
categories: 技术
---

## 迭代器模式
### 1.迭代器是什么？
迭代器是一个对象，它的工作是遍历并选择序列中的对象，它提供了一种访问一个容器对象中的各个元素，而又不必暴露该对象内部细节的方法。
### 2.容器是什么？
在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体
### 3.我们接触过哪些容器，都是干什么用的？
- tomcat容器 如果web服务器应用得到一个指向某个servlet的请求，此时服务器不是把servlet交给servlet本身，而是交给部署该servlet的容器。要有容器向servlet提供http请求和响应，而且要由容器调用servlet的方法，如doPost或者doGet。
- spring容器 Spring容器就是一个巨大的工厂。Spring容器使用Ioc管理所有组成应用系统的组件，用来管理bean的生命周期
- springMVC容器 是Spring的子容器

<!--more-->

### 4.迭代器案例：书架和书

```

// 书
public class Book {

    private String name;

    public Book(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
}

// 书架
public class BookShelf {

    private Book[] books;

    private int last = 0;
    public BookShelf(int maxsize) {
        this.books = new Book[maxsize];
    }
    public Book getBookAt(int index) {
        return books[index];
    }
    public void appendBook(Book book) {
        this.books[last] = book;
        last++;
    }
    public int getLength() {
        return last;
    }

    // 后期放入
    public BookShelfIterator getIterator() {
        return new BookShelfIterator(this);
    }
}

// 迭代器接口
public interface Iterator {

    public abstract boolean hasNext();
    public abstract Object next();
}

// 书架迭代器
public class BookShelfIterator implements Iterator {

    private BookShelf bookShelf;

    private int index;

    public BookShelfIterator(BookShelf bookShelf) {
        this.bookShelf = bookShelf;
        this.index = 0;
    }

    @Override
    public boolean hasNext() {
        if (index < bookShelf.getLength()) {
            return true;
        }
        return false;
    }

    @Override
    public Object next() {
        Book book = bookShelf.getBookAt(index);
        index++;
        return book;
    }
}
```
实现步骤：
1) 创建书本和书架类
2) 定义迭代器接口
3) 创建书本迭代器，需要实现hasNext()方法和next()方法
4) 在书架中添加getLength()和getBookAt()的方法为实现hasnext()和next()接口提供服务
5) 再书架中添加自身迭代器的方法getIterator()

### 5.原理总结
对于迭代器模式总的来说都是相对于集合来说的，主要是用于获取集合自身的元素。可以先定义元素类和集合类，比如书和书架，定义集合的迭代器，可以定义在外部类也可以定义为集合的内部类。获取到自身的迭代器之后就可以从迭代器中逐个获取集合中的元素了。

### 6.ArrayList和hashMap如何获取迭代器？
#### ArrayList
```
  */
    public Iterator<E> iterator() {
        return new Itr();
    }

    /**
     * An optimized version of AbstractList.Itr
     */
    private class Itr implements Iterator<E> {
        int cursor;       // index of next element to return
        int lastRet = -1; // index of last element returned; -1 if no such
        int expectedModCount = modCount;

        public boolean hasNext() {
            return cursor != size;
        }

        @SuppressWarnings("unchecked")
        public E next() {
            checkForComodification();
            int i = cursor;
            if (i >= size)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }

        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        @Override
        @SuppressWarnings("unchecked")
        public void forEachRemaining(Consumer<? super E> consumer) {
            Objects.requireNonNull(consumer);
            final int size = ArrayList.this.size;
            int i = cursor;
            if (i >= size) {
                return;
            }
            final Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length) {
                throw new ConcurrentModificationException();
            }
            while (i != size && modCount == expectedModCount) {
                consumer.accept((E) elementData[i++]);
            }
            // update once at end of iteration to reduce heap write traffic
            cursor = i;
            lastRet = i - 1;
            checkForComodification();
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }
```

#### HashMap
```
 final class KeySet extends AbstractSet<K> {
        public final int size()                 { return size; }
        public final void clear()               { HashMap.this.clear(); }
        public final Iterator<K> iterator()     { return new KeyIterator(); }
        public final boolean contains(Object o) { return containsKey(o); }
        public final boolean remove(Object key) {
            return removeNode(hash(key), key, null, false, true) != null;
        }
        public final Spliterator<K> spliterator() {
            return new KeySpliterator<>(HashMap.this, 0, -1, 0, 0);
        }
        public final void forEach(Consumer<? super K> action) {
            Node<K,V>[] tab;
            if (action == null)
                throw new NullPointerException();
            if (size > 0 && (tab = table) != null) {
                int mc = modCount;
                for (int i = 0; i < tab.length; ++i) {
                    for (Node<K,V> e = tab[i]; e != null; e = e.next)
                        action.accept(e.key);
                }
                if (modCount != mc)
                    throw new ConcurrentModificationException();
            }
        }
    }
```

个人总结：感觉iterator的实现都用到了数组


