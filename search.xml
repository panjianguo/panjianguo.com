<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[建造者(builder)模式]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%BB%BA%E9%80%A0%E8%80%85-builder-%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义建造模式是对象的创建模式。建造模式可以将一个产品的内部表象（internal representation）与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。 模式结构 抽象建造者（Builder）角色：给 出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体建造者 (ConcreteBuilder)角色。具体建造者类必须实现这个接口所要求的两种方法：一种是建造方法(buildPart1和 buildPart2)，另一种是返还结构方法(retrieveResult)。一般来说，产品所包含的零件数目与建造方法的数目相符。换言之，有多少 零件，就有多少相应的建造方法。 具体建造者（ConcreteBuilder）角色：担任这个角色的是与应用程序紧密相关的一些类，它们在应用程序调用下创建产品的实例。这个角色要完成的任务包括：1.实现抽象建造者Builder所声明的接口，给出一步一步地完成创建产品实例的操作。2.在建造过程完成后，提供产品的实例。 导演者（Director）角色：担任这个角色的类调用具体建造者角色以创建产品对象。应当指出的是，导演者角色并没有产品类的具体知识，真正拥有产品类的具体知识的是具体建造者角色。 产品（Product）角色：产品便是建造中的复杂对象。一般来说，一个系统中会有多于一个的产品类，而且这些产品类并不一定有共同的接口，而完全可以是不相关联的。 代码案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 产品类public class Product &#123; /** * 定义一些关于产品的操作 */ private String part1; private String part2; public String getPart1() &#123; return part1; &#125; public void setPart1(String part1) &#123; this.part1 = part1; &#125; public String getPart2() &#123; return part2; &#125; public void setPart2(String part2) &#123; this.part2 = part2; &#125;&#125;// 抽象建造者类public interface Builder &#123; public void buildPart1(); public void buildPart2(); public Product retrieveResult();&#125;// 具体建造者类public class ConcreteBuilder implements Builder &#123; private Product product = new Product(); /** * 产品零件建造方法1 */ @Override public void buildPart1() &#123; //构建产品的第一个零件 product.setPart1(&quot;编号：9527&quot;); &#125; /** * 产品零件建造方法2 */ @Override public void buildPart2() &#123; //构建产品的第二个零件 product.setPart2(&quot;名称：XXX&quot;); &#125; /** * 产品返还方法 */ @Override public Product retrieveResult() &#123; return product; &#125;&#125;// 导演类public class Director &#123; /** * 持有当前需要使用的建造器对象 */ private Builder builder; /** * 构造方法，传入建造器对象 * @param builder 建造器对象 */ public Director(Builder builder)&#123; this.builder = builder; &#125; /** * 产品构造方法，负责调用各个零件建造方法 */ public void construct()&#123; builder.buildPart1(); builder.buildPart2(); &#125;&#125;// 客户端public class Client &#123; public static void main(String[]args)&#123; Builder builder = new ConcreteBuilder(); Director director = new Director(builder); director.construct(); Product product = builder.retrieveResult(); System.out.println(product.getPart1()); System.out.println(product.getPart2()); &#125;&#125; 常见案例java中的@Builder注解用的就是builder模式，builder模式并不一定需要导演类和抽象建造类，灵活一点的话就是只要能够将一个产品分割开来，可以分成不同的对象创建过程去创建对象，就能看作是建造者模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载：学习一下德国人民的翻墙精神]]></title>
    <url>%2F2018%2F09%2F06%2F%E7%BF%BB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[最近常听到有人抱怨翻墙太麻烦，俺心里就嘀咕：你要是知道当年德国人民翻墙的艰辛和危险，或许就不会再抱怨翻 GFW 这堵墙的麻烦了。说到德国人的翻墙，比较关心政治的同学应该会联想到大名鼎鼎的 柏林墙。从某种意义上看，东德共党在 60 年代建造的柏林墙和中国共党在 21 世纪架设的 GFW 真是具有异曲同工之妙——两堵『墙』都是用来阻止本国人民对自由的追求。各位同学们目前的处境，和当年东德老百姓的处境也很类似——都在挖空心思琢磨 翻墙之术。 翻越柏林墙的故事“自由有许多困难，民主亦非完美，然而我们从未建造一堵墙把我们的人民关在里面，不准他们离开。”——肯尼迪《柏林墙下的演说》，1963年6月25日于西德市政厅柏林墙前。 德国的柏林墙是东德于1961年在自己的领土上建立的围墙，目的是不让东德人逃入西柏林，在柏林墙建立之前，大约有250万东德人逃入西柏林，1990年柏林墙被拆除，随后东德加入了联邦德国，两德实现了统一。 肯尼迪曾评价柏林墙是“世界上第一堵不是用于抵御外敌，而是用来对付自家百姓的墙”。但是对于德国人来说，柏林墙所代表的不是肯尼迪，冷战这样的大字眼，而是数以万计小人物的故事，这些小人物在这堵墙边，用自己的生命，造就了人类历史上的一个传说，这个传说的名字，叫做“自由”。 仅在此记录自己了解到的一些故事。常觉得，我国和西方的历史，记录很不一样。在我国的历史记录里，少有这样详尽，乃至繁琐的小人物的记录。所以读西方的历史，经常觉得过于平淡，过于拘泥细节而不见大方向。然而，却自有一种力量在。柏林墙的故事，在西方的历史里，感觉不但不惊天动地，或者剑拔弩张，反而竟然多有幽默。当然，是黑色幽默。 又一个『中国长城』万没有想到，在柏林墙纪念馆会读到我们中国的名字。柏林墙工程的代号，就是“中国长城第二”。 1961年8月，一个沉闷的夏天。对于大量东德人经柏林逃往西方已经忍无可忍的东德人和苏联人搞了一个漂亮的偷袭。8月12日凌晨1点，2万多军队突然开到东西柏林边境，立刻开始了修筑柏林墙的工程。应该说，这个以我国长城命名的工程，准备还是很充分的，绝对不是豆腐渣工程。仅仅到13日凌晨，第一期工程全部完工，整个东西柏林被铁丝网全部分割，再加路障。柏林墙正式树立了起来。 不过上帝实在会开玩笑，就在柏林墙的修筑过程中，东德人就开始了翻越柏林墙，逃亡西德的“柏林墙传说”。东德人的争分夺秒，只争朝夕的精神，给柏林墙的历史研究留下了千古之迷，到底是先有柏林墙，再有翻越行动，还是未等墙树起来，就已经开始了翻越，竟然永远无法得到一个答案了。 历史记载，柏林墙初步完成，即东西柏林正式分割，在13日中午12点37分，最后一个路口宣布封锁为标志。但就在13日，最早明白过来的东德人已经开始用生命搏击柏林墙，当天，一位技工跨过正在树立的铁丝网跳进了西柏林，有人跳进运河游到了西柏林。然而，天意弄人，谁也没想到记录他们踏上西德领土的时间。 13日上午，西德人涌向柏林墙，向墙那边的同胞投掷自己的通行证，身份证件。到苏联军队能够阻止这一举动前，数以千计的证件已经被扔到了东德同胞的手里。大批东德人借机混在返回西柏林的西德人中间偷渡逾越了柏林墙。 13日下午，柏林墙树立以后，第一个逾越柏林墙的人出现了。一个青年在光天化日之下，用百米冲刺的速度飞奔向铁丝网。但是，三名警察追上了他，将他打倒在地，谁也没有想到，被打倒的他竟奇迹般又站了起来，夺过警察的枪，一边与警察对峙一边继续向西柏林飞奔。警察是尽职的，他们不顾这个年轻人的枪，冲上去和他又一次扭打成一团，并且一刀刺进青年人的膝盖。这次这个年轻人失去了奔跑的能力，面对三个警察，结局已经注定。 然而，上天决心要给大家看一幕喜剧而不是悲剧。就在此刻，西柏林群众雷鸣般的怒吼惊醒了三名警察，他们已经越过了柏林墙，现在是在西德的土地上，他们不再是警察，而成了违法者。他们扔下青年跑回柏林墙的另一侧。这个青年拖著残废的腿，一边拼命呼救一边爬到了西柏林。 事后证明，这是一个大大的误会。事实上柏林墙并不是沿东德西德的边境修筑的，而是偏东德一侧，这是为了保证，即使你越过了柏林墙，你仍然在东德土地上，警察和军队仍然有权力和能力开枪将你击毙。当时那三位警察并没有越界，他们大可以合法将那个青年绑回东德。然而，面对这柏林墙上的第一次交锋，他们误会了，害怕了，那个青年简直是奇迹般的竟然这样逃脱了已经笼罩住了自己的厄运。这是第一个通过柏林墙的逃亡者。也许这第一个人就定下了逃亡柏林墙故事的基调。 在柏林墙传说里，有眼泪、有悲壮、有无奈；但同样也有幽默、滑稽和令人含泪微笑的故事。 最可爱的人写可爱是容易的，面对冷酷的现实，人类用自己的信心，幽默来反抗，说起来即使是最大的冷酷，也压不下那希望和温暖。然而要写悲惨，实有些下不了笔。 柏林墙的逃亡者中，那些“功败垂成”者无疑是悲惨的。1961年，18岁的彼得·菲西特就是这么一个人。他已经爬到了柏林墙的顶部，只需要再加最后一把劲，就可以达成目标，就在这个时候，枪声响了……彼得滑落回柏林墙东侧。 悲剧还没有完，身中数弹的彼得倒在柏林墙下，血流如注，我不知道东德的警察是一时不敢承担责任，跑去请示上级，还是真的就已经下了杀心（我宁愿相信是前者）。彼得就这样在墙下躺了50分钟，没有一个东德警察前来管他。 彼得的呼喊声一点一点的低下去了，低下去了。西柏林的人群爆发出愤怒的抗议声。“你们是杀人犯！”“你们是法西斯！”上千群众怒吼著。西德的警察冒险跑到柏林墙边（前面已经说过，这是极其危险的，柏林墙西侧依然是东德的土地，警察已经“越界”，完全可能被枪击）把急救包扔向彼得。但是太晚了，彼得已经失去了自救的能力。彼得终于停止了呼吸。他的血已经流尽了，在他蓝眼睛里最后映出的，依然是东柏林。50分钟以后，东德警察抬走了他的尸体。 如果说彼得最大的不幸在于他最终没有成功，我不知道下面这个最后“成功”的例子，是不是算幸运。在柏林墙刚完成的那一年，由于墙还不是很坚固，有人就想出了办法，开重型车辆直接撞墙！直接冲开柏林墙进入西德。1961年，这类事件多达14起。 逃亡者要面对的绝不仅仅是坚固的高墙，还有来自军队和警察的密集射击。有军事常识的朋友都知道，对于穿透力极强的子弹，民用的车壁，车门根本就是nothing，香港电影里躲到小轿车后面就可以逃开对方射击的镜头完全是搞笑。所以，用这个办法冲击柏林墙的人，实际上等于完全不设防的穿行在枪林弹雨中，去争取一次严重交通事故的机会！ 这里的故事太多，最悲惨的，一是在离墙最后一米处熄火的那辆装有数十人的大客车。二就是布鲁希克的故事。 布鲁希克和他的同伙同样是利用大客车冲击柏林墙，但是他们的行动从一开始就被发现了。军队和警察从多个方向向客车密集射击，客车起火燃烧，弹痕累累！还好，客车质量过硬，不但没有熄火，还在布鲁希克良好的驾驶下奋勇加速，一声巨响，柏林墙被撞开了一个大缺口，整个客车冲进了西柏林！ 欢呼的人群拥上来迎接，却被眼前的景象震惊了，驾驶座上的布鲁希克身中19 弹，他是用生命的最后意志坚持加速，冲向柏林墙的。当客车冲进西柏林的那一刻，布鲁希克停止了呼吸。 柏林人展开了一场争论，布鲁希克究竟有没有看到他梦想看到的西柏林？最后是一个现场镜头宽慰了大家，从镜头上看，客车驾驶座位于西柏林之后，布鲁希克还有一个抬头的动作。是的，那时候他还活著！他的眼睛最后映出的，是他梦想中的迦南西柏林！他是一个成功者。 柏林墙在两德统一后完全拆毁，后来联邦政府作了很大努力说服人民同意在原址重建了一段70米的“柏林墙”作为警示，图中十字架是企图越墙者的墓碑，为纪念他们追求自由的勇气把他们葬在这里让人凭吊。在28年中，至少有239人在试图翻越柏林墙或潜渡施普雷河时被枪杀。 这个镜头我也看了，说实话，在那样的动荡，混乱，和快速行驶中，每个人都被颠簸得相当厉害，硬要说那个几乎无法注意到的动作是布鲁希克自己作出来的而不是别的原因，我感觉实在是勉强。但是，谁又愿意继续辩论下去呢？谁又不希望这个年轻人生命的最后时刻能够是快乐呢？德国人如此不严谨的结论很少，却少得可爱，少得美丽。 柏林墙倒塌以后，新建成的文化宫，专门采用了很特殊的设计。建筑之间均用伞状结构连接，整个原来的柏林墙东侧“死亡开阔地”被全部笼罩在保护伞下。成为了伞下的广场。 我的德国同学说，这是因为，在这个广场上，无数逃亡者因为没有任何隐蔽物，只好强行穿越在火力控制下的广场而失去生命。现在，德国终于可以为自己的公民提供隐蔽物了，尽管，已经太迟，太迟…… 我无话可说。 咱们德国人都是工程师上面那篇太沉重了，来一点轻快的。 德国人的机械设计，制造能力举世闻名，在柏林墙逃亡中，那也是充份体现了德国人民的技术水平。要按现在流行的歌来唱，那就是：“咱们这嘎都是德国人，咱们这嘎特产工程师，咱们这嘎香肠配啤酒，咱们这嘎都是活本茨”（本茨，即奔驰汽车创始人，德国工程师）。 1968年，一位东德青年利用河流潜水到达西德。大家心目中的潜水是什么样的？潜水服？潜水镜？总之他一个人能有多大本事，还一切都必须自己造，最多是一点粗糙的个人潜水工具罢？ 非也，这位青年自己造的是——潜 - 水 - 艇！ 他用的是摩托车马达，配上自己组装的钢板，还有导航，压缩气体等系统。硬是在家造出了一个个人用的小潜水艇。质量如何？我看可以通过ISO9002国际认证。这潜水艇在水下航行了超过5个小时，才从西德那边冒出来，其中没有发生任何事故。有同学说了，5个小时是不是太长了一点？那是没办法的事情，你试试拿个小摩托的马达去潜水看看。 这小潜水艇当然是一个奇迹，该青年的逃亡过程使他立刻在西德找到了工作，各大机械公司竞相聘用该青年为设计师。听说后来他还真在机械设计上大有成就。 不过小潜水艇也就算了，后面来了个更狠的，逃亡中一不小心，楞搞了个吉尼斯记录出来。 1979年某夜晚，从东德一个家庭的后院升起了一个巨大的热气球。气球下面的吊篮里装著两个家庭——两对夫妇和他们的四个孩子。这个气球完全由这两个家庭手工制成，花了数年的时间。在此期间，两个家庭自学成才，从材料学，工程学，气体动力学，气象学……一直到建立家庭实验室，最后成功的在家庭的后院里制作完成了这个高达28米的热气球！ 经调查，此热气球是欧洲历史上最大的热气球，被记入吉尼斯世界记录！ 这个热气球在通过柏林墙的时候，被警察发现了。警察目瞪口呆之余，还算记得开枪射击。这一射击，该气球良好的工艺水准就发挥了出来。逃亡者操纵热气球一下升高到了2800米以上的高空，不但枪打不到，连探照灯都照不到！警察只好紧急呼叫空军支援：“长江长江，我是黄河，你们赶快出动，寻找一个热气球，把它打下来。对！没错！是热气球！重复一遍，热 - 气 - 球！” 苏联空军的“苏”、“米”战机立刻出动，但是热气球在28分钟的飞行以后，已经完成了使命，安全落地。 问题是，当气球被发现以后，两家人决定立刻降落，以避免被战机击落。这一“紧急降落”，就谁也摸不准方向了——降落的地点无法确定。到底是已经到了西德，还是被迫降在东德，谁也不知道。 估计在他们数年的学习中没有心理学的功课，面对未知的前景，8个人都失去了验证的勇气。他们根本不敢走出这个气球，就这样躲在吊篮里长达24小时之久。他们已经没有勇气亲自揭晓自己的命运了。他们唯一能做的，就是祈祷。降落整整24小时以后，军人来了，揭开了气球。他们对这8个逃亡者说出了他们盼望了多少年的话。——“你们自由了，这里是西德领土。” 还有一个地下逃亡的工程也是让人叹为观止。它是一条穿越柏林墙的地下隧道。这条隧道全长145米。距地面距离是12米。就是说，这隧道先如挖井一样，向地底直着往下挖12米深，然后在开始往柏林墙方向挖。隧道的进口，设在一所房子后院的厕所里，而出口是一个老点心面包店的地窖。隧道内部高度不足一米，确切地说，只有70公分。否则，在这种秘密状态下，太多的土将无法化解在屋子里。大量的土用小推车运送到地道口，再拉上井，分散在屋子里。一共有36个青年和一位23岁的女青年参加了这项秘密工程。他们由此营救出了他们的未婚妻和朋友，以及他们全然不认识的家庭。 值得一提的是，这个隧道不是从东柏林往西柏林挖，而是由西柏林往东柏林挖。之所以仍然要秘密地处理挖出来的土，大概是因为在救出所有要救的人之前，仍然需要小心谨慎，不走漏风声：谁知道西柏林是否有东柏林的间谍？ 但问题是，如果从东柏林往西柏林挖，出口可以不必忧虑，反正只要到了西柏林，那里都是自由的土地，都可以光明正大地走出来。但是从西柏林往东柏林挖，出口就必须事先设计好，必须正好是一个隐蔽的出口。 这些西柏林的营救们，是怎样使出口正好挖通在一个房子后院的厕所里的呢？他们又不能公然和秘密警察监视下的东柏林一方联系、讨论；就是秘密联系讨论也不可能公然测量距离、方向和位置；就是公然测量了，又怎样方位、距离分毫不爽地可可从人家后院的厕所里挖出？ 这应当是工于计算、思维精密、办事严谨的德国人逃亡到西柏林的又一个杰作。 这项秘密工程不声不响地进行了六个月。57位东柏林人成功地从这个隧道中出逃。从开始挖土，到逃亡者最后爬出隧道，在12米深的井口下坐着缆绳，始见西柏林的自由天日，人们为这一工程全过程拍下了珍贵的照片。这些照片除了传递当时的作业情况，还向后人传递着另一种信息：救助者们在挖下第一铲土时就知道他们一定会成功，而且只能成功，否则，这些照片随时可以成为治罪的证据。 世上无难事，只要肯钻研下面这个故事，证明了这个世界上永远有些事情，你是连想象都想象不出来的。 如果让你把一个人藏在小汽车里偷越柏林墙，你会把他藏在哪里？后箱？底盘？座位下面？恐怕没有一个人会想象得出来，把人藏在汽车的引擎部份。不要说那里因为发动机的缘故温度高，废气多，人放那里多半不烫死也憋死，就算没这些问题，您随便掀开哪辆车的引擎盖看看，怎么可能放得下人？ 然而事实证明，那里可以放下一个人，而且这个人可以在引擎旁边至少呆2个小时以上，还保持清醒。9个从引擎中逃亡柏林墙的东德人可以作证。他们的故事甚至连金庸先生描写的什么“缩骨功”也相形见绌。 据资料显示，他们都是把自己扭曲成，成，很难说他们把自己扭曲成什么形状了。总之他们就好象没有骨头，可以随便变形的橡皮泥一样，把自己一点一点的塞进了引擎与盖子之间的缝隙里。然后就这样逾越了柏林墙。到达西柏林以后，他们要用1-2小时的时间，再一点一点把自己“还原”。先出来一条腿，再伸出一个头，逐渐的，一个人的形状硬是从引擎里升了起来。如果放一个快镜头，简直就是《终结者II》的翻版。 在录像上，一大群西德的热心人在旁边帮忙。但是很快，“不许帮忙”就成了规矩。因为逃亡者的姿势实在太古怪，只能由本人来逐渐恢复。没有经验的人只能是越帮越忙。 在香港电影里，警察或者匪徒，经常从人行天桥上一跃而下，正好落在驶过的汽车顶上。这对于我们来说是电影，对于柏林人却是生活的一部份。 凡靠近柏林墙的高楼，都成了东德人“跳楼”的场所。不必担心，这里的跳楼可不是求死，而是求生。只要你爬到楼上，表现出逃亡的意图，西柏林的同胞们就抬著床单蜂拥前来接应。鼓足勇气，一跃而下，只要把握了方向，就可以在空中逾越柏林墙，落到床单上。 当然，不是每个人都有这么高的运动天份的。曾经有一家三口一起跳楼。6岁的孩子成功了，父亲和母亲却摔到了地面，一个伤了内脏，一个伤了脊椎。在短短的跳楼时代，有4个人因跳楼而死亡。 年纪最大的跳楼者是一位77岁的老太太。她在跳下来之前，把自己吓得瘫倒在了地板上。无论大家怎么鼓励，怎么哀求也无法跳下来。就在西柏林人准备失望的散去的时候，一个意外发生了。东柏林的警察发现了情况，冲进了大楼。警察破门的声音给了老太太无穷的动力，她冲向窗口，果断的一跃而下…… 再后来，由于柏林墙西侧仍属于东德，接应的西德人算侵犯了东德领土，跳楼者又改用汽车接应。顶部预先布置的汽车突然冲向柏林墙，跳楼者就把握这一刹那裹著被子飞跃而下，直扑汽车顶部。汽车又马上退回西柏林内部。 直到东德下了决心，把柏林墙东德一侧的高楼全部推平，空出一片几百米的“恐怖区”以后，居然还有人延续了这个跳楼逃亡法。某位德国工程师设计了一个强力弹射装置，从东柏林市内的高楼起跳，“弹”了数百米到达西柏林，然后利用自己制造的降落伞缓缓落地。 柏林墙的倒掉历史的进程到了1989年下半年，东德已经是强弩之末。由于东德政府70年代以来所实行的指令性经济、农业全面集体化、强力发展重工业、严厉打击国内反对声音的经济、政治政策，导致经济发展几乎停滞，210亿美元的外债债台高筑、东德马克内债累累，环境污染严重，人民生活贫穷压抑，严重的不满情绪早以深深埋伏在社会民心之中。 1989年11月9日，新东德政府开始计划放松对东德人民的旅游限制，但由于当时东德的中央政治局委员君特·沙博夫斯基对上级命令的误解，错误地宣布柏林墙即将开放，导致数以万计的市民走上街头。 这一天，就象上紧了发条的钟表，突然失去指针，滴滴答答的钟声尤在，却不知何始何终——柏林墙的两面人山人海，鸦雀无声。 面对这堵耸立了28年，阻绝两德人民，制造了无数悲欢离合、生死哭歌、惨重牺牲的血墙，人们无法判断的是：当制造它的独裁政府部门和官员辞职的辞职，改选的改选时，柏林墙辞职了吗？它是否仍然戒备森严？它还能随意射杀越墙的逃亡者吗？自动射击装置是否完全解除？密堡暗碉里的岗哨是否仍然轮流值班？带缰绳可以自由追踪100米的警犬是否正严阵以待？ 没有任何官方的媒体报道这些与人们生息密切相关的消息。柏林墙依然无声地矗立着。它两面成千上万被阻隔的人们遥遥相对，心中纵有万马奔腾，脚却不敢越雷池一步。 这是继两次世界大战之后，德国又一个历时转折的关头。而历史在这一瞬间干脆停下了脚步，为的是让人们记住它的沧桑。 不知道渴望自由的人们同这面血墙对视了多久，终于有一个东德的青年人，壮着胆子，往那禁区的空地，试探着，迈出一只脚…… 没有反应。让脚落地，移动身体重心，再迈出另一只脚…… 仍然没有发现任何警戒方面的反应。 小伙子双脚落在东柏林境内的禁区，人，暴露在自动枪击射程之内。 柏林墙两岸，无数双眼睛被这年轻的躯体所抓住，人们不约而同屏神静息等待着……要么枪声乍起，又一具尸体倒卧在血泊中；要么人民淹没、踏碎这围墙。 小伙子不急不徐，却一步千斤，载着两德的万众一心，牵着两德张开的手臂，在众目暌暌之下，从那片社会主义东德境内的边境开阔地，一寸一寸、一米一米走向资本主义西柏林境内。 这应当是德国历史上，街头上最安静最紧张的时刻了。 当小伙子在身前身后人山人海的无声的注视下，终于接近柏林墙，奋力攀上墙顶，预期的枪声仍然没有响起，紧张的人们却沉默得几乎要爆炸。 然后，西柏林一边向这位以命相抵、探试自由的青年人伸出了丛林般的手臂；然后，小伙子双脚结结实实踏上了西柏林自由的土地。 一瞬间，柏林墙两岸人声鼎沸，心旌摇荡，激动的情感潮流如洪水决堤。人们相互拥抱接吻，相互重复诉告着那个刚刚发现的不可思议的事实：柏林墙解放了！它的警卫事实上已然解除！它已经全然不过就是一堵墙而已了！ 两德人们相互拥入对方，成千上万的人们彻夜不眠地享受着亲友重逢的喜悦。两德人民拥满柏林墙墙上墙下墙东墙西，人们举杯相庆，奏乐狂欢，欢乐的自发的庆典持续数日，节日的气氛经久不消。 无论如何，柏林墙的故事已经结束了（而且，是喜剧性的结束）。人间的故事，如柏林墙这般悲惨的并不少，能够最终这样收场的，已经很不错了。 德国人毕竟是幸运的，柏林墙见证了德国人的痛苦，全世界分享了他们的痛苦。他们被关注着。然而，还有那么多的人，他们的痛苦竟然是完全默然的。 柏林墙倒下了，东德人终于获得了他们梦寐以求的自由。然而，类似的悲剧却并没有在这里地球上结束。我们看到在远隔德国万里重洋的另外一个国家，依旧有一堵用来对付自己的百姓的墙巍峨耸立着。 唯一的区别是：大多数人看不到甚至不知道这堵墙。 本文引自学习一下德国人民的翻墙精神科学上网的终极姿势]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2018%2F09%2F06%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、模式动机建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。 二、模式定义观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 三、模式角色观察者模式包含如下角色： Subject: 目标 ConcreteSubject: 具体目标 Observer: 观察者 ConcreteObserver: 具体观察者 四、模式实例图 五、实例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/** * 主题 */public interface Subject &#123; // 观察者注册 public void registerObserver(Observer o); // 删除观察者 public void removeObserver(Observer o); // 当主题有内容更新时调用，用于通知观察者 public void notifyObserver();&#125;/** * 观察者 */public interface Observer &#123; // 当气象站观测的天气发生变化时，主题会把参数值传给观察者 public void update(float temp);&#125;/** * 用于布告板显示 */public interface DisplayElement &#123; // 在显示布告板上显示的操作 public void display();&#125;/** * 气象站实现主题，发布气象信息（气温） */public class WeatherStation implements Subject&#123; private ArrayList observers; private float temp; public WeatherStation() &#123; // 加个ArrayList存放所有注册的Observer对象; observers = new ArrayList&lt;&gt;(); &#125; @Override public void registerObserver(Observer o) &#123; // 当新的观察者注册时添加进来 observers.add(o); &#125; @Override public void removeObserver(Observer o) &#123; // 当观察者取消注册时去除该观察者 int i = observers.indexOf(o); if (i&gt;=0) &#123; observers.remove(i); &#125; &#125; @Override public void notifyObserver() &#123; // 更新状态，调用Observer的update告诉观察者有新的信息 for (int i = 0; i &lt; observers.size(); i++) &#123; Observer observer = (Observer) observers.get(i); observer.update(temp); &#125; &#125; /* * 此方法用于气象站收到的数据,并且调用更新使数据实时通知给观察者 */ public void setMeasurements(float temp)&#123; this.temp = temp; System.out.println(&quot;气象站测量的温度为：&quot; + temp + &quot;℃&quot;); notifyObserver(); &#125;&#125;/** * 布告板上的状态显示 */public class ConditionDisplay implements Observer,DisplayElement&#123; private float temp; private Subject weatherStation; public ConditionDisplay(Subject weatherStation) &#123; // 构造时需要间主题/被观察者对象作为注册之用 this.weatherStation = weatherStation; weatherStation.registerObserver(this); &#125; @Override public void display() &#123; // 将数据显示在布告板上 System.out.println(&quot;布告板显示当前温度为：&quot; + temp + &quot;℃&quot;); &#125; @Override public void update(float temp) &#123; // 接受来自主题/被观察者（气象站）的数据 this.temp = temp; display(); &#125;&#125;/** * 天气观测站 */public class WeatherObserver &#123; public static void main(String[] args) &#123; // 首先创建一个主题/被观察者 WeatherStation weatherStation = new WeatherStation(); // 创建观察者并将被观察者对象传入 ConditionDisplay conditionDisplay = new ConditionDisplay(weatherStation); // 设置气象站模拟收到的气温数据 weatherStation.setMeasurements(25); weatherStation.setMeasurements(24); weatherStation.setMeasurements(23); &#125;&#125; JAVA内置观察者模式可以使用java内置的观察者模式，这样就无需自己写Subject和Observer类了，在java.util包下继承的Observable和实现Observer类即可。其修改后的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 继承java内置的被观察者，因此不再需要注册和删除了 */public class WeatherStationN extends Observable&#123; private float temperature; public WeatherStationN() &#123; // 由于继承了Observable，它已经创建了一个Vector来存放Observer对象的容器，所以此处不用再建立ArrayList &#125; /* * 此方法用于气象站收到的数据,并且调用更新使数据实时通知给观察者 */ public void setMeasurements(float temp)&#123; this.temperature = temp; System.out.println(&quot;气象站测量的温度为：&quot; + temp + &quot;℃&quot;); // 更新强调用表示有状态更新 setChanged(); notifyObservers(temperature); &#125;&#125;/** * 实现java内置Observer接口 */public class ConditionDisplayN implements java.util.Observer,DisplayElement&#123; private Observable observable; private float temp; public ConditionDisplayN(Observable observable) &#123; // 构造器需要Observable作为参数 this.observable = observable; observable.addObserver(this); &#125; @Override public void display() &#123; // 将数据显示在布告板上 System.out.println(&quot;布告板显示当前温度为：&quot; + temp + &quot;℃&quot;); &#125; @Override public void update(Observable o, Object arg) &#123; // 当被观察者有更新使触发 if (o instanceof WeatherStationN) &#123; this.temp = (float) arg; display(); &#125; &#125;&#125;/** * 天气观测站 */public class WeatherObserver &#123; public static void main(String[] args) &#123; // 首先创建一个主题/被观察者 WeatherStationN weatherStationN = new WeatherStationN(); // 创建观察者并将被观察者对象传入 ConditionDisplayN conditionDisplayN = new ConditionDisplayN(weatherStationN); // 设置气象站模拟收到的气温数据 weatherStationN.setMeasurements(30); weatherStationN.setMeasurements(25); weatherStationN.setMeasurements(20); &#125;&#125; 六、自我理解观察者模式的作用是通过一对多的关系依赖，当一个对象状态发生改变时，通过松耦合的方式改变一系列对象的状态。 原理实现的话就是在被观察者对象里创建一个观察者列表，然后再把观察者注入被观察者的观察者列表中.当被观察者中的状态改变时，调用通知方法，然后逐个调用各个观察者的update方法，改变观察者的状态。 观察者模式很容易和监听事件模式搞混，观察者模式的通知不包含事件源，但是事件模式是发送一个事件通知各个事件监听器，是包含事件源的。 七、参考文献观察者模式的简单例子]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F2018%2F09%2F05%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[动态代理动态代理：在程序运行时，通过反射机制动态地创建一个代理类。 模式要点分析1) 动态的体现：程序开始执行时是没有代理类的，在程序运行时，java利用反射机制动态生成代理类的实例2) jdk技术支持：java在java.lang.reflect包里提供两个类/接口帮助我们创建和使用代理类实例，一个是Proxy类，一个是InvocationHandler接口。3) 两种代理类的模式区别：静态模式要求为程序中所有需要被访问的目标创建代理类，如果有10种代理目标，我们就得创建10个代理类，让代理类直接访问目标对象。 下面是其简易关系图： 动态代理则是在程序调用某个目标类时才通过反射创建代理类的实例，创建过程并不是在开发层面可见的，又加之常常需要在代理类中进行一些额外操作来加强目标类的功能，如果代理类不可见我们就不能达到这个目的，所以这时在代理类和被代理类之间就需要一个第三者，帮助我们完成功能增强，它就是InvocationHandler。 下面是其简易关系图： 动态代理代码案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// proxy 源码public class Proxy implements Serializable &#123; //被代理类构造函数的参数类型，即InvocationHandler private static final Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler.class &#125;; //代理对象的创建方法，通过Proxy.newProxyInstance(...)生成代理对象 public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) &#123; ...省去一些方法，只显示核心代码 final Class&lt;?&gt;[] intfs = interfaces.clone(); //1，通过类加载器和接口创建代理类 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); //2，通过反射获取代理类中public类型的构造，且参数类型为InvocationHandler final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; //3，通过构造，创建代理类的实例对象，并返回 return cons.newInstance(new Object[]&#123;h&#125;); &#125; //通过类加载器和接口，动态创建代理类。 public static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class... interfaces) &#123;...&#125; &#125;// 接口public interface Subject &#123; public String getResponse(String url); public void getCookie(String url); public String getUpdateTime();&#125;// 目标对象接口实现public class TargetSubject implements Subject &#123; @Override public String getResponse(String url) &#123; Log.e(&quot;miss08&quot;, &quot;执行业务方法：getResponse .&quot; + url); return &quot;2017/10/03 21:56&quot;; &#125; @Override public void getCookie(String url) &#123; Log.e(&quot;miss08&quot;, &quot;执行业务方法：getCookie .&quot; + url); &#125; @Override public String getUpdateTime() &#123; Log.e(&quot;miss08&quot;, &quot;执行业务方法：getUpdateTime .&quot;); long time = System.currentTimeMillis(); return String.valueOf(time); &#125;&#125;// 创建handler，实现InvocationHandler，Proxy创建代理类建时需要这个handler参数。public class DynamicInvocationHandler implements InvocationHandler &#123; private Subject subject; public DynamicInvocationHandler(Subject subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) &#123; Log.e(&quot;miss08&quot;, &quot;开始执行代理方法，处理的方法是 ： &quot; + method.getName()); //通过反射获取到接口的method，执行subject目标对象中带参数args的method方法 String response = (String) method.invoke(subject, args); Log.e(&quot;miss08&quot;, &quot;业务方法处理完毕,响应结果是 ： &quot; + response); return response; &#125;&#125;// 测试public class Test &#123; public static void main(String[] args) &#123; Subject targetSubject = new TargetSubject(); InvocationHandler handler = new DynamicInvocationHandler(targetSubject); log.info(&quot;miss08,开始创建代理类&quot;); Class&lt;?&gt;[] interfaces = targetSubject.getClass().getInterfaces(); ClassLoader classLoader = Subject.class.getClassLoader(); //创建代理类的实例 Subject proxySubject = (Subject) Proxy.newProxyInstance(classLoader , interfaces , handler); log.info(&quot;miss08,代理类实例创建成功&quot;); //调用代理类的getResponse方法 proxySubject.getResponse(&quot;http://192.168.1.100:8080/currentTime&quot;); &#125;&#125; 动态代理源码流程： image 自我理解1) 生成调用处理对象1InvocationHandler handler = new DynamicInvocationHandler(targetSubject); 2) 创建代理实例123456789// 目标类的接口集合Class&lt;?&gt;[] interfaces = targetSubject.getClass().getInterfaces();// 类加载器ClassLoader classLoader = Subject.class.getClassLoader();//创建代理类的实例Subject proxySubject = (Subject) Proxy.newProxyInstance(classLoader , interfaces , handler); (Subject) Proxy.newProxyInstance(classLoader , interfaces , handler)方法中包含3步 通过类加载器和接口创建代理类1Class&lt;?&gt; cl = getProxyClass0(loader, intfs); 其中intfs是调用接口列表 通过反射获取代理类中public类型的构造，且参数类型为InvocationHandler 1final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); 通过构造，创建代理类的实例对象，并返回 1cons.newInstance(new Object[]&#123;h&#125;) 猜测proxySubject伪代码：1234567891011public class ProxySubject &#123; private InvocationHandler handler; public ProxySubject(InvocationHandler handler) &#123; this.handler = handler; &#125; public void getResponse (String s) &#123; handler.invoke(this, this.getClass().getMethod(&quot;getResponse&quot;, String.class), s) &#125;&#125; 3) 调用代理类的getResponse方法1proxySubject.getResponse(&quot;http://192.168.1.100:8080/currentTime&quot;) 4) handler调用1invoke(Object proxy, Method method, Object[] args) 5) 实际调用12//通过反射获取到接口的method，执行subject目标对象中带参数args的method方法 String response = (String) method.invoke(subject, args); 6) 调用实际对象的getResponse方法 动态代理待用流程图 参考文献java设计模式（三）代理模式之静态代理和动态代理模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态代理]]></title>
    <url>%2F2018%2F09%2F04%2F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[java 静态代理1.简介为其他对象提供一种代理以控制对这个对象的访问称为代理。 定义要点：1) 其他对象：目标对象，想要访问的对象，常被称为被委托对象或被代理对象。2) 提供一种代理：这里”一种”两个字比较重要，为什么不是提供一个呢？一种代表了某一类，即代理类和被代理类必须实现同一接口，这个接口下的所有实现类都能被代理访问到，其实只是单纯的为了实现代理访问功能，代理类不实现任何接口也能完成，不过针对于面向接口的编程，这种方式更易于维护和扩展，代理类实现接口，不管目标对象怎么改或改成谁，代理类不需要任何修改，而且任何目标对象能使用的地方都能用代理去替换。3) 通过代理访问目标对象：代理类需要持有目标对象的引用，这样用户可以通过代理类访问目标对象，实现了用户与目标对象的解耦。4) 访问：访问二字说明代理对象的目的是访问被代理类，业务逻辑的具体执行与其无关，由被代理对象完成。5) 为什么要通过代理来访问：设计模式都是为了解决某一类的问题，可能目标对象不想让该用户访问或者是该用户无法访问到目标对象，这样就需要一个第三者来建立他们的联系，如代理服务器情景，被访问的服务器设置防火墙过滤掉某些地址的访问，这时用户就可以通过一个代理服务器来访问目标，使得目标服务器不用对外暴露细节，用户也能访问到想访问的数据。6) 代理类功能增强：代理对象能直接访问到目标对象，这样它就能在调用目标对象的某个方法之前做一个预处理，在调用方法之后进行一些结尾工作，这样就对目标对象的方法进行了增强。但是我们不能说代理模式提供对象功能的增强，它的设计初衷是对代理对象施加控制，只是这种设计思路能达到功能增强的目的 2.代理模式类图 3.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 接口public interface IHttpInvokeSubject &#123; public String invoke(String request);&#125;// 真实主题public class RealSubject implements IHttpInvokeSubject &#123; @Override public String invoke(String request) &#123; //具体业务逻辑 Log.e(&quot;miss08&quot;, &quot;开始处理请求中...&quot;); Log.e(&quot;miss08&quot;, &quot;请求处理完毕，返回响应数据&quot;); return &quot;response&quot;; &#125;&#125;//代理类提供访问，并且对一些功能进行解决public class ProxySubject implements IHttpInvokeSubject &#123; private IHttpInvokeSubject subject; public ProxySubject(IHttpInvokeSubject subject) &#123; this.subject = subject; &#125; @Override public String invoke(String request) &#123; String deRequest = decodeRequest(request); String response = subject.invoke(deRequest); String enResponse = encodeRequest(response); return enResponse; &#125; //对于所有请求，对于每个请求都要处理的的解码工作可以在这里处理 private String decodeRequest(String request) &#123; Log.e(&quot;miss08&quot;, &quot;对请求数据解码&quot;); return &quot;解码后的请求&quot;; &#125; //对响应数据，附加上数据的编码格式，发送给浏览器 private String encodeRequest(String response) &#123; Log.e(&quot;miss08&quot;, &quot;给响应数据附加编码格式后，发送给客户端&quot;); return &quot;编码后的响应&quot;; &#125;&#125; 4.使用按照如上静态代理模式，真实对象和代理类实现相同的接口IHttpInvokeSubject，代理类ProxySubject在类中定义接口对象属性subject，提供接口实现类参数的构造方法ProxySubject(IHttpInvokeSubject subject)，实现接口方法中调用真实对象的接口方法。 参考java设计模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker使用]]></title>
    <url>%2F2018%2F09%2F03%2Fdocker%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[docker 简介Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）。几乎没有性能开销，可以很容易地在机器和数据中心中运行。最重要的是，他们不依赖于任何语言、框架包括系统。 一、CentOS6.x安装docker1) 更新yum源1yum update -y 2) 通过安装docker-io软件包来安装Docker1yum -y install docker-io 3) 启动docker进程1service docker on 4) 让docker在服务器启动时启动1chkconfig docker on 二、Docker 使用1） 查询和拉取镜像 12docker search mysql:5.7docker pull mysql:5.7 2) 列出镜像 1234[root@vultr /]# docker imagesREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEhub.c.163.com/library/mysql 5.7 573ca163b053 11 months ago 407.1 MBmysql 5.7 573ca163b053 11 months ago 407.1 MB 3) 运行docker 1234567docker run -d -p 3306:3306 --name mymysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7-d 表示后台云信docker镜像-p 表示端口号，前一个8080是指我们访问tomcat时的端口号，后一个8080是tomcat启动的一个容器在docker中运行的端口号，指定端口号为了更明确的访问tomcat。 tomcat:last last是指定的tomcat的标签，相同的镜像可以指定不同的标签以做区分。 4) 列出正在运行的容器 123[root@vultr /]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES94ee2b979517 mysql:5.7 &quot;docker-entrypoint.s 2 days ago Up 2 days 0.0.0.0:3306-&gt;3306/tcp mysqlserver 5) 进入容器1docker exec -it 94ee2b979517 /bin/bash 6) 停止运行容器 1docker stop 44d9be4dca95 7) 移除容器和移除镜像12docker rm 44d9be4dca95 // 移除容器docker rmi 4b8387148088 // 移除镜像 三、docker 安装mysql1.下载镜像，mysql 5.71docker pull mysql:5.7 2.创建mysql容器，并后台启动1docker run -d -p 3306:3306 -e MYSQL_USER=&quot;woniu&quot; -e MYSQL_PASSWORD=&quot;123456&quot; -e MYSQL_ROOT_PASSWORD=&quot;123456&quot; --name mysqltest1 mysql:5.7 --character-set-server=utf8 --collation-server=utf8_general_ci 参数说明：-e MYSQL_USER=”root” ：添加root用户 -e MYSQL_PASSWORD=”123456”：设置添加的用户密码 -e MYSQL_ROOT_PASSWORD=”123456”：设置root用户密码 –character-set-server=utf8：设置字符集为utf8 –collation-server=utf8_general_cli：设置字符比较规则为utf8_general_cli 3.挂载外部配置和数据安装1) 创建目录和配置文件my.cnf1234567891011121314151617mkdir /dockermkdir /docker/mysqlmkdir /docker/mysql/confmkdir /docker/mysql/data 创建my.cnf配置文件touch /docker/mysql/conf/my.cnf my.cnf添加如下内容：[mysqld]user=mysqlcharacter-set-server=utf8default_authentication_plugin=mysql_native_password[client]default-character-set=utf8[mysql]default-character-set=utf8 2) 创建容器，并后台启动 1docker run -d -p 3306:3306 --privileged=true -v /docker/mysql/conf/my.cnf:/etc/my.cnf -v /docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysqltest2 mysql:5.7 参数说明： –privileged=true：容器内的root拥有真正root权限，否则容器内root只是外部普通用户权限 -v /docker/mysql/conf/my.cnf:/etc/my.cnf：映射配置文件 -v /docker/mysql/data:/var/lib/mysql：映射数据目录]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2018%2F05%2F02%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[IOC容器IOC(Inverse of Control) 控制反转对于软件来说，某一接口具体实现类的选择控制权从调用类中移除，转交给第三方决定。IOC也被叫做依赖注入， 类装载器 ClassLoader类装载器就是寻找类的字节码文件并狗仔出类在JVM内部表示的对象组件。在java中，类装载器吧一个类装入jvm中，要经过一下步骤：1) 装载2) 连接3) 初始化 三个转载器： ClassLoader 根装载器，C语言编写 ExtClassLoader 扩展类装载器 AppClassLoader 系统类扩展器，负责装载Classpath路径下的类包获取类装载器：1ClassLoader loader = Thread.currentThread().getContextClassLoader(); java中无论某个类生成多少个对象，这些对象都对应于同一个Class对象 反射都是再程序进行时，不是编译的时候 1) 获取类加载器1ClassLoader loader = Thread.currentThread().getContextClassLoader(); 2) 获取类类型12Class SampleClass = loader.loadClass(&quot;com.panjianguo.service.SampleClass&quot;);// Class SampleClass = Class.fromName(&quot;com.panjianguo.service.SampleClass&quot;); 下面的方法实际上是Class封装的方法，实际上都是先获取当前线程的类加载器，然后类加载器通过类的全限定名获取到类的类型对象3) 获取类的构造函数反射类1Constructor declaredConstructor = SampleClass.getDeclaredConstructor(); 4) 通过构造函数反射类创建对象12com.panjianguo.service.SampleClass sample = (SampleClass) declaredConstructor.newInstance();// com.panjianguo.service.SampleClass sampleClass1 = (SampleClass) SampleClass.newInstance(); 下面通过类名直接调用newInstance方法实际上也是调用了反射构造函数的newInstance方法，从而创建了对应类的对象5) 获取类的方法反射类1Method setName = SampleClass.getMethod(&quot;setName&quot;, String.class); 6) 方法调用1setName.invoke(sampleClass, &quot;小明&quot;);]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2F2018%2F02%2F05%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[迭代器模式1.迭代器是什么？迭代器是一个对象，它的工作是遍历并选择序列中的对象，它提供了一种访问一个容器对象中的各个元素，而又不必暴露该对象内部细节的方法。 2.容器是什么？在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体 3.我们接触过哪些容器，都是干什么用的？ tomcat容器 如果web服务器应用得到一个指向某个servlet的请求，此时服务器不是把servlet交给servlet本身，而是交给部署该servlet的容器。要有容器向servlet提供http请求和响应，而且要由容器调用servlet的方法，如doPost或者doGet。 spring容器 Spring容器就是一个巨大的工厂。Spring容器使用Ioc管理所有组成应用系统的组件，用来管理bean的生命周期 springMVC容器 是Spring的子容器 4.迭代器案例：书架和书1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 书public class Book &#123; private String name; public Book(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;// 书架public class BookShelf &#123; private Book[] books; private int last = 0; public BookShelf(int maxsize) &#123; this.books = new Book[maxsize]; &#125; public Book getBookAt(int index) &#123; return books[index]; &#125; public void appendBook(Book book) &#123; this.books[last] = book; last++; &#125; public int getLength() &#123; return last; &#125; // 后期放入 public BookShelfIterator getIterator() &#123; return new BookShelfIterator(this); &#125;&#125;// 迭代器接口public interface Iterator &#123; public abstract boolean hasNext(); public abstract Object next();&#125;// 书架迭代器public class BookShelfIterator implements Iterator &#123; private BookShelf bookShelf; private int index; public BookShelfIterator(BookShelf bookShelf) &#123; this.bookShelf = bookShelf; this.index = 0; &#125; @Override public boolean hasNext() &#123; if (index &lt; bookShelf.getLength()) &#123; return true; &#125; return false; &#125; @Override public Object next() &#123; Book book = bookShelf.getBookAt(index); index++; return book; &#125;&#125; 实现步骤：1) 创建书本和书架类2) 定义迭代器接口3) 创建书本迭代器，需要实现hasNext()方法和next()方法4) 在书架中添加getLength()和getBookAt()的方法为实现hasnext()和next()接口提供服务5) 再书架中添加自身迭代器的方法getIterator() 5.原理总结对于迭代器模式总的来说都是相对于集合来说的，主要是用于获取集合自身的元素。可以先定义元素类和集合类，比如书和书架，定义集合的迭代器，可以定义在外部类也可以定义为集合的内部类。获取到自身的迭代器之后就可以从迭代器中逐个获取集合中的元素了。 6.ArrayList和hashMap如何获取迭代器？ArrayList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172*/ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; HashMap1234567891011121314151617181920212223242526final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; 个人总结：感觉iterator的实现都用到了数组]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis学习笔记]]></title>
    <url>%2F2018%2F01%2F18%2Fredis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、 redis简介redis是什么？ redis是REmote Dictionary Server(远程字典服务器)的缩写，它以字典结构存储数据，并允许其他应用通过TCP协议读取字典中的内容。Redis是一个开源的、高性能的、基于键值对的缓存与存储系统，通过提供多种键值数据类型来适应不同场景下的缓存与存储需求。同时 Redis 的诸多高层级功能使其可以胜任消息队列、任务队列等不同的角色。 redis有哪些特性1) redis通过键值对的方式存储，键值数据类型如下： 字符串类型 散列类型 列表类型 集合类型 有序集合类型2) 内存存储与持久化，redis的数据都存储在内存中，对于硬盘存储存在明显的速度优势。程序退出后内存中的数据会丢失,但是Redis提供了对持久化的支持，即可以将内存中的数据异步写入到硬盘中，同时不影响继续提供服务。3) 功能丰富4) 简单稳定。redis有100多个命令，但常用的就十几个，redis用C语言编写，并且开源。5) redis是一个单线程程序，同一时刻只能处理一个客户端的请求。redis是通过IO多路复用来处理多个客户端请求的。伪代码：12345while True: # 当没有客户端发请求时，redis会阻塞在select调用 clients = select(...); for client in clients: processRequest(client) redis采用队列模式讲并发访问变为串行访问。redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法： 客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。 服务器角度，利用setnx（SET if Not eXists）实现锁。语法：SETNX key value功能：将 key 的值设为 value ，当且仅当 key 不存在；若给定的 key 已经存在，则 SETNX 不做任何动作。二、redis安装mac 安装redis1) brew install redis2) 安装目录：/usr/local/Cellar/redis/3.2.83) 添加至开机启动项12$ ln -f /usr/local/Cellar/redis/2.8.13/homebrew.mxcl.redis.plist ~/Library/LaunchAgents/$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.redis.plist 4) 启动redis 启动 redis-server5) redis默认端口及配置文件 REDISPORT=6379 EXEC=/usr/local/bin/redis-server CLIEXEC=/usr/local/bin/redis-cli PIDFILE=/var/run/redis_${REDISPORT}.pid CONF=/etc/redis/${REDISPORT}.conf6) 关闭redis 关闭redis redis-cli shutdown 或者 kill redis 三、redis通用命令redis命令1) redis-cli -h 127.0.0.1 -p 63792) redis-cli PING3) redis-cli 不带参数进入redis交互模式4) 配置redis日志级别 redis-server /path/to/redis.conf –loglevel warning redis&gt; CONFIG SET loglevel warning 取值与赋值1) set key value2) get key3) incr key 递增数字 DECR key 减少数字（下面的递增递减省略）4) incrby key integer 增加指定的整数5) incrbyfloat key float 增加指定的双精度浮点数6) append key value 向尾部追加值7) strlen key 获取字符串长度8) mset key1 value1 key2 value2 … 设置多个键值对9) mget key1 key2 … 根据多个键值对获取多个值10) 位操作：（感觉不常用） GETBIT key offset GETBIT命令可以获得一个字符串类型键指定位置的二进制位的值（0或1），索引从0开始，如果需要获取的二进制位的索引超出了键值的二进制位的实际长度则默认位值是0 SETBIT key offset value SETBIT 命令可以设置字符串类型键指定位置的二进制位的值，返回值是该位置的旧值，如果要设置的位置超过了键值的二进制位的长度，SETBIT命令会自动将中间的二进制位设置为0，同理设置一个不存在的键的指定二进制位的值会自动将其前面的位赋值为0 BITCOUNT key [start] [end] BITCOUNT命令可以获得字符串类型键中值是1的二进制位个数可以通过参数来限制统计的字节范围 BITOP operation destkey key [key …] BITOP命令可以对多个字符串类型键进行位运算，并将结果存储在destkey参数指定的键中。BITOP命令支持的运算操作有AND、OR、XOR和NOT redis类型1.散列类型（1）介绍 Redis 是采用字典结构以键值对的形式存储数据的，而散列类型（hash）的键值也是一种字典结构，其存储了字段（field）和字段值的映射，但字段值只能是字符串，不支持其他数据类型，换句话说，散列类型不能嵌套其他的数据类型。一个散列类型键可以包含至多232−1个字段。 提示 除了散列类型，Redis 的其他数据类型同样不支持数据类型嵌套。比如集合类型的每个元素都只能是字符串，不能是另一个集合或散列表等。 散列类型适合存储对象：使用对象类别和 ID 构成键名，使用字段表示对象的属性，而字段值则存储属性值。 （2）命令1) HSET key field value2) HGET key field3) HMSET key field value [field value …]4) HMGET key field [field …]5) HGETALL key6) HEXISTS key field 判断字段是否存在7) HSETNX key field value 当前字段不存在时赋值8) HINCRBY key field increment 增加数字9) HDEL key field [field …] 删除字段10) HKEYS key 只获取对象的所有字段名11) HVALUES key 只获取对象的所有字段值 2.列表类型(1) 介绍 列表类型（list）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为O(1)，获取越接近两端的元素速度就越快。 (2) 命令1) lpush key value1 value2… 从列表的左边开始增加元素2) rpush key value1 value2… 从列表的右边开始增加元素3) lpop key 从列表左边弹出第一个元素4) rpop key 从列表右边弹出第一个元素5) llen key 获取列表中元素的个数6) lrange key start stop 获取列表片段7) lrem key count value 从左边删除列表中指定个数的值 当 count &gt; 0时 LREM 命令会从列表左边开始删除前 count 个值为 value的元素 当 count &lt; 0时 LREM 命令会从列表右边开始删除前|count|个值为 value 的元素 当 count = 0是 LREM命令会删除所有值为 value的元素8) lindex key index 获取key列表的第index个元素9) lset key index value 将key列表的第index个元素设置为value10) ltrim key start end 删除key列表索引start，end之外的所有元素11) linsert key before elem value 从左向右找到第一个值为elem的元素,在它之前添加一个值为value的元素12) linsert key after elem value 从做向右找到第一个值为elem的元素，在它之后添加一个值为value的元素13) rpoplpush source target 将source列表的最右边的一个元素移动到target列表的最左边，多次调用可实现列表元素的转移 3.集合类型（1）介绍 集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型在Redis内部是使用值为空的散列表（hash table）实现的，所以这些操作的时间复杂度都是O(1)。集合无序，唯一，和列表类型一样，只能有至多232−1个字段。1) sadd key member1 member2… 向集合key添加成员m1 m22) srem key member1 member2… 移除集合key中的成员m1 m23) sismember key member 判断member是否在key集合中4) smembers key 返回集合中的所有元素5) sdiff set1 set2 set3… 差集运算（set1 - set2 -set3)6) sinser set1 set2 set3… 交集运算7) sunion set1 set2 set3… 并集运算8) scard set 获取集合中的元素个数9) srandmember key count 随机获取key集合中获取count个元素10) spop key 从集合中弹出一个元素 4.有序集合类型（1）介绍在集合类型的基础上有序集合类型为集合中的每个元素都关联了一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在等集合类型支持的操作，还能够获得分数最高（或最低）的前N个元素、获得指定分数范围内的元素等与分数有关的操作。虽然集合中每个元素都是不同的，但是它们的分数却可以相同。有序集合类型在某些方面和列表类型有些相似1) 二者都是有序的。2) 二者都可以获得某一范围的元素。 但是二者有着很大的区别，这使得它们的应用场景也是不同的。 列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会较慢，所以它更加适合实现如“新鲜事”或“日志”这样很少访问中间元素的应用。 有序集合类型是使用散列表和跳跃表（Skip list）实现的，所以即使读取位于中间部分的数据速度也很快（时间复杂度是O(log(N))）。 列表中不能简单地调整某个元素的位置，但是有序集合可以（通过更改这个元素的分数）。 有序集合要比列表类型更耗费内存。有序集合类型算得上是Redis的5种数据类型中最高级的类型了，在学习时可以与列表类型和集合类型对照理解。 (2) 命令1) zadd key score1 member1 score2 member2… 分数不仅可以是整数，还可以是双精度浮点数2) zscore key member 获取key集合中member元素的分数3) zrange key start stop 按照分数大小获取集合key中索引在start和end之间的元素4) zrange key start stop WITHSCORES 按照分数大小获取集合key中索引在start和stop之间的元素以及它们的分数5) zrevrange key start stop 按照元素分数从大到小获取key集合中索引在start和stop之间的元素6) zrangebyscore key min max 【withscores】【limit offset count】其中加上limit offset count ，即在获得的元素列表的基础上向后偏移offset个元素，并且只获取前count个元素，和mysql的limit命令相似，min和max可以替换成-inf和+inf表示负无穷和正无穷7) zincrby key increment member 增加某个元素的分数8) zcard key 获取集合中元素的数量9) zcount key min max 获取指定分数范围内的元素个数10) zrem key member1 member2… 删除一个或多个元素11) zremrangebyrank key start stop 按照元素分数从小到大的舒徐删除处在指定排名范围内的所有元素，并返回删除的元素数量12) zremrangebyscore key min max 删除指定分数范围内的所有元素13) zrangk key member 获取元素的排名(从小到大)14) zrevrangk key member 获取元素的排名(从大到小)15) zinterstore destination numkeys key1 key2… [weights weight1 weight2…][aggregate sum|min|max] zinterstore用来计算多个有序集合的交集并将结果存储在destination键中（同样以有序集合存储），**destination键中元素的分数是由AGGREGATE参数决定的。12345678910111213141516171819202122232425262728293031323334353637(1）当AGGREGATE是SUM时（也就是默认值），destination键中元素的分数是每个参与计算的集合中该元素分数的和。例如：- redis&gt; ZADD sortedSets1 1 a 2 b- (integer) 2- redis&gt; ZADD sortedSets2 10 a 20 b- (integer) 2- redis&gt; ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2- (integer) 2redis&gt; ZRANGE sortedSetsResult 0 -1 WITHSCORES- &quot;a&quot;- &quot;11&quot;- &quot;b&quot;- &quot;22&quot;（2）当AGGREGATE是MIN时，destination键中元素的分数是每个参与计算的集合中该元素分数的最小值。例如：redis&gt; ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 AGGREGATE MIN(integer) 2redis&gt; ZRANGE sortedSetsResult 0 -1 WITHSCORES1) &quot;a&quot;2) &quot;1&quot;3) &quot;b&quot;4) &quot;2&quot;（3）当AGGREGATE是MAX时，destination键中元素的分数是每个参与计算的集合中该元素分数的最大值。例如：redis&gt; ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 AGGREGATE MAX(integer) 2redis&gt; ZRANGE sortedSetsResult 0 -1 WITHSCORES1) &quot;a&quot;2) &quot;10&quot;3) &quot;b&quot;4) &quot;20&quot;ZINTERSTORE命令还能够通过WEIGHTS参数设置每个集合的权重，每个集合在参与计算时元素的分数会被乘上该集合的权重。例如：redis&gt; ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 WEIGHTS 1 0.1(integer) 2redis&gt; ZRANGE sortedSetsResult 0 -1 WITHSCORES1) &quot;a&quot;2) &quot;2&quot;3) &quot;b&quot;4) &quot;4&quot;另外还有一个命令与ZINTERSTORE命令的用法一样，名为ZUNIONSTORE，它的作用是计算集合间的并集，这里不再赘述。 进阶1.事务（1）介绍redis中的事务是一组命令的集合。事务和命令一样都是redis的最小执行单位。redis中的错误类型分为两种： 语法错误：语法错误指命令不存在或者命令参数的人数不对。 运行错误：运行错误指在命令执行时出现的错误，比如乱用命令。 12345678910Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：批量操作在发送 EXEC 命令前被放入队列缓存。收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。一个事务从开始到执行会经历以下三个阶段：1.开始事务。2.命令入队。3.执行事务。 （2）命令 disard 取消事务，放弃执行事务块内的所有命令 exec 执行所有事务块内的命令 multi 开启事务 unwatch 取消watch命令对所有key的监视 watch key1 key2… 监视key1 key2等,watch监控对象之后，不能如果这个对象需要在事务内重新设值，那么这个对象不能在事务开启之前设值。如下：12345678910111213141516171819202122232425262728293031323334127.0.0.1:6379&gt; watch key1OK127.0.0.1:6379&gt; set key1 2OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set key1 3QUEUED127.0.0.1:6379&gt; exec(nil) // 错误，未执行设值127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set key1 2QUEUED127.0.0.1:6379&gt; exec1) OK127.0.0.1:6379&gt; set key1 4OK127.0.0.1:6379&gt; get key1&quot;4&quot;127.0.0.1:6379&gt; watch key1OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set key1 3QUEUED127.0.0.1:6379&gt; set key1 5QUEUED127.0.0.1:6379&gt; exec1) OK2) OK127.0.0.1:6379&gt; get key1&quot;5&quot;127.0.0.1:6379&gt; (3) 过期时间 expire key seconds 设置key多少秒后过期 返回1表示成功，0表示失败 ttl key 返回值表示过期剩余秒数，-1表示没有过期时间，-2表示键已删除或者键不存在 persist key 取消键的过期时间设置 1成功，0失败除了persist命令之外，使用set或getset命令为键赋值也同样会清除键的过期时间，其他只对键值进行操作的命令（如incr，lpush，hset，zrem）均不会影响键的过期时间 pexpire key milliseconds 设置key多少毫秒后过期 expireat key unixseconds 设置key的过期时间点，时间点为unix的时间格式，就是时间点到1970-01-01 00:00:00时间点的秒数 pexpireat key unixmillseconds (4) redis 实现缓存123456789当服务器内存有限时，如果大量地使用缓存键且过期时间设置得过长就会导致 Redis 占满内存；另一方面如果为了防止 Redis 占用内存过大而将缓存键的过期时间设得太短，就可能导致缓存命中率过低并且大量内存白白地闲置。实际开发中会发现很难为缓存键设置合理的过期时间，为此可以限制 Redis 能够使用的最大内存，并让Redis按照一定的规则淘汰不需要的缓存键，这种方式在只将Redis用作缓存系统时非常实用。具体的设置方法为：修改配置文件的maxmemory参数，限制Redis最大可用内存大小（单位是字节），当超出了这个限制时Redis会依据maxmemory-policy参数指定的策略来删除不需要的键直到Redis占用的内存小于指定内存。· noeviction：当内存使用达到阈值的时候，所有引起申请内存的命令会报错。· allkeys-lru：在主键空间中，优先移除最近未使用的key。· volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的key。· allkeys-random：在主键空间中，随机移除某个key。· volatile-random：在设置了过期时间的键空间中，随机移除某个key。· volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的key优先移除。 (4) 排序 sort key sort命令可以对集合，列表，有序集合进行排序，数据只能是数值类型,排序只依赖数值的大小 sort key alpha 通过alpha参数实现按照字典顺序排列非数字元素 sort key desc limit start index 参考mysql sort list by somekey:* desc sort list by somekey:*-&gt;item desc 参考自: 李子骅. “Redis入门指南（第2版）”。 redis并发问题]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java事物隔离级别]]></title>
    <url>%2F2018%2F01%2F16%2Fjava%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[形成原因： java多线程并发导致读取数据时出现了一些问题： 脏读:一个事务读取了另一个未提交的并行事务写的数据 不可重复读:一个事务重新读取前面读取过的数据， 发现该数据已经被另一个已提交的事务修改过 幻读:一个事务重新执行一个查询，返回一套符合查询条件的行， 发现这些行因为其他最近提交的事务而发生了改变 事物隔离级别 读未提交（Read uncommitted） 读已提交（Readcommitted） 可重复读（Repeatableread） 可串行化（Serializable） 隔离级别与问题对应关系]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring表达式语言]]></title>
    <url>%2F2018%2F01%2F07%2FSpring%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[Spring表达式语言:SpEL(一段简单的spel入门代码)简介Spring表达式语言（简称SpEl）是一个支持查询和操作运行时对象导航图功能的强大的表达式语言. 它的语法类似于传统EL，但提供额外的功能，最出色的就是函数调用和简单字符串的模板函数。 尽管有其他可选的 Java 表达式语言，如 OGNL, MVEL,JBoss EL 等等，但 Spel 创建的初衷是了给 Spring 社区提供一种简单而高效的表达式语言，一种可贯穿整个 Spring 产品组的语言。这种语言的特性应基于 Spring 产品的需求而设计。 功能简述表达式语言支持以下功能： 文字表达式 布尔和关系运算符 正则表达式 类表达式 访问 properties, arrays, lists, maps 方法调用 关系运算符 参数 调用构造函数 Bean引用 构造Array 内嵌lists 内嵌maps 三元运算符 变量 用户定义的函数 集合投影 集合筛选 模板表达式 代码样例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.panjianguo.service;import org.springframework.expression.EvaluationContext;import org.springframework.expression.Expression;import org.springframework.expression.ExpressionParser;import org.springframework.expression.spel.standard.SpelExpressionParser;import org.springframework.expression.spel.support.StandardEvaluationContext;import java.lang.reflect.Method;/** * 一句话功能简述 */public class SpelTest &#123; public static void main(String[] args) throws NoSuchMethodException &#123; //创建解析器 ExpressionParser parser = new SpelExpressionParser(); //解析表达式 Expression expression = parser.parseExpression("#decorate('Hello '+#person.name+#end)"); //构造上下文 EvaluationContext context = new StandardEvaluationContext(); //为end参数值来赋值 context.setVariable("end", "!"); // 为对象赋值 Person person = new Person("小明", "男", 18); context.setVariable("person", person); // 为方法赋值 Method decorate = SpelTest.class.getDeclaredMethod("decorate", String.class); context.setVariable("decorate", decorate); //打印expression表达式的值 System.out.println(expression.getValue(context)); &#125; // 人员 static class Person &#123; private String name; private String gender; private Integer age; Person(String name, String gender, Integer age) &#123; this.name = name; this.gender = gender; this.age = age; &#125; public String getName() &#123; return name; &#125; &#125; // 修饰方法 static String decorate(String content) &#123; return "***"+content+"***"; &#125;&#125; 执行输出值1234/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/bin/java ...***Hello 小明!***Process finished with exit code 0 主要步骤1) 创建解析器2) 给解析器设置解析表达式3) 创建构造上下文4) 为构造上下文设置转化参数5) 解析器通过构造上下文将解析表达式转化成想要的内容（在SpEL表达式中，默认情况下，表达式前缀为 ‘ # ‘ ，而后缀为 ‘ } ‘ 。如果表达式中没有前缀和后缀，那么表达式字符串就被当作纯文本。）]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
