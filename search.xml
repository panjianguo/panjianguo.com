<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[docker使用]]></title>
    <url>%2F2018%2F09%2F03%2Fdocker%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[docker 简介Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）。几乎没有性能开销，可以很容易地在机器和数据中心中运行。最重要的是，他们不依赖于任何语言、框架包括系统。 一、CentOS6.x安装docker1) 更新yum源1yum update -y 2) 通过安装docker-io软件包来安装Docker1yum -y install docker-io 3) 启动docker进程1service docker on 4) 让docker在服务器启动时启动1chkconfig docker on 二、Docker 使用1） 查询和拉取镜像 12docker search mysql:5.7docker pull mysql:5.7 2) 列出镜像 1234[root@vultr /]# docker imagesREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEhub.c.163.com/library/mysql 5.7 573ca163b053 11 months ago 407.1 MBmysql 5.7 573ca163b053 11 months ago 407.1 MB 3) 运行docker 1234567docker run -d -p 3306:3306 --name mymysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7-d 表示后台云信docker镜像-p 表示端口号，前一个8080是指我们访问tomcat时的端口号，后一个8080是tomcat启动的一个容器在docker中运行的端口号，指定端口号为了更明确的访问tomcat。 tomcat:last last是指定的tomcat的标签，相同的镜像可以指定不同的标签以做区分。 4) 列出正在运行的容器 123[root@vultr /]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES94ee2b979517 mysql:5.7 &quot;docker-entrypoint.s 2 days ago Up 2 days 0.0.0.0:3306-&gt;3306/tcp mysqlserver 5) 进入容器1docker exec -it 94ee2b979517 /bin/bash 6) 停止运行容器 1docker stop 44d9be4dca95 7) 移除容器和移除镜像12docker rm 44d9be4dca95 // 移除容器docker rmi 4b8387148088 // 移除镜像 三、docker 安装mysql1.下载镜像，mysql 5.71docker pull mysql:5.7 2.创建mysql容器，并后台启动1docker run -d -p 3306:3306 -e MYSQL_USER=&quot;woniu&quot; -e MYSQL_PASSWORD=&quot;123456&quot; -e MYSQL_ROOT_PASSWORD=&quot;123456&quot; --name mysqltest1 mysql:5.7 --character-set-server=utf8 --collation-server=utf8_general_ci 参数说明：-e MYSQL_USER=”root” ：添加root用户 -e MYSQL_PASSWORD=”123456”：设置添加的用户密码 -e MYSQL_ROOT_PASSWORD=”123456”：设置root用户密码 –character-set-server=utf8：设置字符集为utf8 –collation-server=utf8_general_cli：设置字符比较规则为utf8_general_cli 3.挂载外部配置和数据安装1) 创建目录和配置文件my.cnf1234567891011121314151617mkdir /dockermkdir /docker/mysqlmkdir /docker/mysql/confmkdir /docker/mysql/data 创建my.cnf配置文件touch /docker/mysql/conf/my.cnf my.cnf添加如下内容：[mysqld]user=mysqlcharacter-set-server=utf8default_authentication_plugin=mysql_native_password[client]default-character-set=utf8[mysql]default-character-set=utf8 2) 创建容器，并后台启动 1docker run -d -p 3306:3306 --privileged=true -v /docker/mysql/conf/my.cnf:/etc/my.cnf -v /docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysqltest2 mysql:5.7 参数说明： –privileged=true：容器内的root拥有真正root权限，否则容器内root只是外部普通用户权限 -v /docker/mysql/conf/my.cnf:/etc/my.cnf：映射配置文件 -v /docker/mysql/data:/var/lib/mysql：映射数据目录]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2018%2F05%2F02%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[IOC容器IOC(Inverse of Control) 控制反转对于软件来说，某一接口具体实现类的选择控制权从调用类中移除，转交给第三方决定。IOC也被叫做依赖注入， 类装载器 ClassLoader类装载器就是寻找类的字节码文件并狗仔出类在JVM内部表示的对象组件。在java中，类装载器吧一个类装入jvm中，要经过一下步骤：1) 装载2) 连接3) 初始化 三个转载器： ClassLoader 根装载器，C语言编写 ExtClassLoader 扩展类装载器 AppClassLoader 系统类扩展器，负责装载Classpath路径下的类包获取类装载器：1ClassLoader loader = Thread.currentThread().getContextClassLoader(); java中无论某个类生成多少个对象，这些对象都对应于同一个Class对象 反射都是再程序进行时，不是编译的时候 1) 获取类加载器1ClassLoader loader = Thread.currentThread().getContextClassLoader(); 2) 获取类类型12Class SampleClass = loader.loadClass(&quot;com.panjianguo.service.SampleClass&quot;);// Class SampleClass = Class.fromName(&quot;com.panjianguo.service.SampleClass&quot;); 下面的方法实际上是Class封装的方法，实际上都是先获取当前线程的类加载器，然后类加载器通过类的全限定名获取到类的类型对象3) 获取类的构造函数反射类1Constructor declaredConstructor = SampleClass.getDeclaredConstructor(); 4) 通过构造函数反射类创建对象12com.panjianguo.service.SampleClass sample = (SampleClass) declaredConstructor.newInstance();// com.panjianguo.service.SampleClass sampleClass1 = (SampleClass) SampleClass.newInstance(); 下面通过类名直接调用newInstance方法实际上也是调用了反射构造函数的newInstance方法，从而创建了对应类的对象5) 获取类的方法反射类1Method setName = SampleClass.getMethod(&quot;setName&quot;, String.class); 6) 方法调用1setName.invoke(sampleClass, &quot;小明&quot;);]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2F2018%2F02%2F05%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[迭代器模式1.迭代器是什么？迭代器是一个对象，它的工作是遍历并选择序列中的对象，它提供了一种访问一个容器对象中的各个元素，而又不必暴露该对象内部细节的方法。 2.容器是什么？在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体 3.我们接触过哪些容器，都是干什么用的？ tomcat容器 如果web服务器应用得到一个指向某个servlet的请求，此时服务器不是把servlet交给servlet本身，而是交给部署该servlet的容器。要有容器向servlet提供http请求和响应，而且要由容器调用servlet的方法，如doPost或者doGet。 spring容器 Spring容器就是一个巨大的工厂。Spring容器使用Ioc管理所有组成应用系统的组件，用来管理bean的生命周期 springMVC容器 是Spring的子容器 4.迭代器案例：书架和书1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 书public class Book &#123; private String name; public Book(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;// 书架public class BookShelf &#123; private Book[] books; private int last = 0; public BookShelf(int maxsize) &#123; this.books = new Book[maxsize]; &#125; public Book getBookAt(int index) &#123; return books[index]; &#125; public void appendBook(Book book) &#123; this.books[last] = book; last++; &#125; public int getLength() &#123; return last; &#125; // 后期放入 public BookShelfIterator getIterator() &#123; return new BookShelfIterator(this); &#125;&#125;// 迭代器接口public interface Iterator &#123; public abstract boolean hasNext(); public abstract Object next();&#125;// 书架迭代器public class BookShelfIterator implements Iterator &#123; private BookShelf bookShelf; private int index; public BookShelfIterator(BookShelf bookShelf) &#123; this.bookShelf = bookShelf; this.index = 0; &#125; @Override public boolean hasNext() &#123; if (index &lt; bookShelf.getLength()) &#123; return true; &#125; return false; &#125; @Override public Object next() &#123; Book book = bookShelf.getBookAt(index); index++; return book; &#125;&#125; 实现步骤：1) 创建书本和书架类2) 定义迭代器接口3) 创建书本迭代器，需要实现hasNext()方法和next()方法4) 在书架中添加getLength()和getBookAt()的方法为实现hasnext()和next()接口提供服务5) 再书架中添加自身迭代器的方法getIterator() 5.原理总结对于迭代器模式总的来说都是相对于集合来说的，主要是用于获取集合自身的元素。可以先定义元素类和集合类，比如书和书架，定义集合的迭代器，可以定义在外部类也可以定义为集合的内部类。获取到自身的迭代器之后就可以从迭代器中逐个获取集合中的元素了。 6.ArrayList和hashMap如何获取迭代器？ArrayList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172*/ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; HashMap1234567891011121314151617181920212223242526final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; 个人总结：感觉iterator的实现都用到了数组]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis学习笔记]]></title>
    <url>%2F2018%2F01%2F18%2Fredis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、 redis简介redis是什么？ redis是REmote Dictionary Server(远程字典服务器)的缩写，它以字典结构存储数据，并允许其他应用通过TCP协议读取字典中的内容。Redis是一个开源的、高性能的、基于键值对的缓存与存储系统，通过提供多种键值数据类型来适应不同场景下的缓存与存储需求。同时 Redis 的诸多高层级功能使其可以胜任消息队列、任务队列等不同的角色。 redis有哪些特性1) redis通过键值对的方式存储，键值数据类型如下： 字符串类型 散列类型 列表类型 集合类型 有序集合类型2) 内存存储与持久化，redis的数据都存储在内存中，对于硬盘存储存在明显的速度优势。程序退出后内存中的数据会丢失,但是Redis提供了对持久化的支持，即可以将内存中的数据异步写入到硬盘中，同时不影响继续提供服务。3) 功能丰富4) 简单稳定。redis有100多个命令，但常用的就十几个，redis用C语言编写，并且开源。5) redis是一个单线程程序，同一时刻只能处理一个客户端的请求。redis是通过IO多路复用来处理多个客户端请求的。伪代码：12345while True: # 当没有客户端发请求时，redis会阻塞在select调用 clients = select(...); for client in clients: processRequest(client) redis采用队列模式讲并发访问变为串行访问。redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法： 客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。 服务器角度，利用setnx（SET if Not eXists）实现锁。语法：SETNX key value功能：将 key 的值设为 value ，当且仅当 key 不存在；若给定的 key 已经存在，则 SETNX 不做任何动作。二、redis安装mac 安装redis1) brew install redis2) 安装目录：/usr/local/Cellar/redis/3.2.83) 添加至开机启动项12$ ln -f /usr/local/Cellar/redis/2.8.13/homebrew.mxcl.redis.plist ~/Library/LaunchAgents/$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.redis.plist 4) 启动redis 启动 redis-server5) redis默认端口及配置文件 REDISPORT=6379 EXEC=/usr/local/bin/redis-server CLIEXEC=/usr/local/bin/redis-cli PIDFILE=/var/run/redis_${REDISPORT}.pid CONF=/etc/redis/${REDISPORT}.conf6) 关闭redis 关闭redis redis-cli shutdown 或者 kill redis 三、redis通用命令redis命令1) redis-cli -h 127.0.0.1 -p 63792) redis-cli PING3) redis-cli 不带参数进入redis交互模式4) 配置redis日志级别 redis-server /path/to/redis.conf –loglevel warning redis&gt; CONFIG SET loglevel warning 取值与赋值1) set key value2) get key3) incr key 递增数字 DECR key 减少数字（下面的递增递减省略）4) incrby key integer 增加指定的整数5) incrbyfloat key float 增加指定的双精度浮点数6) append key value 向尾部追加值7) strlen key 获取字符串长度8) mset key1 value1 key2 value2 … 设置多个键值对9) mget key1 key2 … 根据多个键值对获取多个值10) 位操作：（感觉不常用） GETBIT key offset GETBIT命令可以获得一个字符串类型键指定位置的二进制位的值（0或1），索引从0开始，如果需要获取的二进制位的索引超出了键值的二进制位的实际长度则默认位值是0 SETBIT key offset value SETBIT 命令可以设置字符串类型键指定位置的二进制位的值，返回值是该位置的旧值，如果要设置的位置超过了键值的二进制位的长度，SETBIT命令会自动将中间的二进制位设置为0，同理设置一个不存在的键的指定二进制位的值会自动将其前面的位赋值为0 BITCOUNT key [start] [end] BITCOUNT命令可以获得字符串类型键中值是1的二进制位个数可以通过参数来限制统计的字节范围 BITOP operation destkey key [key …] BITOP命令可以对多个字符串类型键进行位运算，并将结果存储在destkey参数指定的键中。BITOP命令支持的运算操作有AND、OR、XOR和NOT redis类型1.散列类型（1）介绍 Redis 是采用字典结构以键值对的形式存储数据的，而散列类型（hash）的键值也是一种字典结构，其存储了字段（field）和字段值的映射，但字段值只能是字符串，不支持其他数据类型，换句话说，散列类型不能嵌套其他的数据类型。一个散列类型键可以包含至多232−1个字段。 提示 除了散列类型，Redis 的其他数据类型同样不支持数据类型嵌套。比如集合类型的每个元素都只能是字符串，不能是另一个集合或散列表等。 散列类型适合存储对象：使用对象类别和 ID 构成键名，使用字段表示对象的属性，而字段值则存储属性值。 （2）命令1) HSET key field value2) HGET key field3) HMSET key field value [field value …]4) HMGET key field [field …]5) HGETALL key6) HEXISTS key field 判断字段是否存在7) HSETNX key field value 当前字段不存在时赋值8) HINCRBY key field increment 增加数字9) HDEL key field [field …] 删除字段10) HKEYS key 只获取对象的所有字段名11) HVALUES key 只获取对象的所有字段值 2.列表类型(1) 介绍 列表类型（list）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为O(1)，获取越接近两端的元素速度就越快。 (2) 命令1) lpush key value1 value2… 从列表的左边开始增加元素2) rpush key value1 value2… 从列表的右边开始增加元素3) lpop key 从列表左边弹出第一个元素4) rpop key 从列表右边弹出第一个元素5) llen key 获取列表中元素的个数6) lrange key start stop 获取列表片段7) lrem key count value 从左边删除列表中指定个数的值 当 count &gt; 0时 LREM 命令会从列表左边开始删除前 count 个值为 value的元素 当 count &lt; 0时 LREM 命令会从列表右边开始删除前|count|个值为 value 的元素 当 count = 0是 LREM命令会删除所有值为 value的元素8) lindex key index 获取key列表的第index个元素9) lset key index value 将key列表的第index个元素设置为value10) ltrim key start end 删除key列表索引start，end之外的所有元素11) linsert key before elem value 从左向右找到第一个值为elem的元素,在它之前添加一个值为value的元素12) linsert key after elem value 从做向右找到第一个值为elem的元素，在它之后添加一个值为value的元素13) rpoplpush source target 将source列表的最右边的一个元素移动到target列表的最左边，多次调用可实现列表元素的转移 3.集合类型（1）介绍 集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型在Redis内部是使用值为空的散列表（hash table）实现的，所以这些操作的时间复杂度都是O(1)。集合无序，唯一，和列表类型一样，只能有至多232−1个字段。1) sadd key member1 member2… 向集合key添加成员m1 m22) srem key member1 member2… 移除集合key中的成员m1 m23) sismember key member 判断member是否在key集合中4) smembers key 返回集合中的所有元素5) sdiff set1 set2 set3… 差集运算（set1 - set2 -set3)6) sinser set1 set2 set3… 交集运算7) sunion set1 set2 set3… 并集运算8) scard set 获取集合中的元素个数9) srandmember key count 随机获取key集合中获取count个元素10) spop key 从集合中弹出一个元素 4.有序集合类型（1）介绍在集合类型的基础上有序集合类型为集合中的每个元素都关联了一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在等集合类型支持的操作，还能够获得分数最高（或最低）的前N个元素、获得指定分数范围内的元素等与分数有关的操作。虽然集合中每个元素都是不同的，但是它们的分数却可以相同。有序集合类型在某些方面和列表类型有些相似1) 二者都是有序的。2) 二者都可以获得某一范围的元素。 但是二者有着很大的区别，这使得它们的应用场景也是不同的。 列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会较慢，所以它更加适合实现如“新鲜事”或“日志”这样很少访问中间元素的应用。 有序集合类型是使用散列表和跳跃表（Skip list）实现的，所以即使读取位于中间部分的数据速度也很快（时间复杂度是O(log(N))）。 列表中不能简单地调整某个元素的位置，但是有序集合可以（通过更改这个元素的分数）。 有序集合要比列表类型更耗费内存。有序集合类型算得上是Redis的5种数据类型中最高级的类型了，在学习时可以与列表类型和集合类型对照理解。 (2) 命令1) zadd key score1 member1 score2 member2… 分数不仅可以是整数，还可以是双精度浮点数2) zscore key member 获取key集合中member元素的分数3) zrange key start stop 按照分数大小获取集合key中索引在start和end之间的元素4) zrange key start stop WITHSCORES 按照分数大小获取集合key中索引在start和stop之间的元素以及它们的分数5) zrevrange key start stop 按照元素分数从大到小获取key集合中索引在start和stop之间的元素6) zrangebyscore key min max 【withscores】【limit offset count】其中加上limit offset count ，即在获得的元素列表的基础上向后偏移offset个元素，并且只获取前count个元素，和mysql的limit命令相似，min和max可以替换成-inf和+inf表示负无穷和正无穷7) zincrby key increment member 增加某个元素的分数8) zcard key 获取集合中元素的数量9) zcount key min max 获取指定分数范围内的元素个数10) zrem key member1 member2… 删除一个或多个元素11) zremrangebyrank key start stop 按照元素分数从小到大的舒徐删除处在指定排名范围内的所有元素，并返回删除的元素数量12) zremrangebyscore key min max 删除指定分数范围内的所有元素13) zrangk key member 获取元素的排名(从小到大)14) zrevrangk key member 获取元素的排名(从大到小)15) zinterstore destination numkeys key1 key2… [weights weight1 weight2…][aggregate sum|min|max] zinterstore用来计算多个有序集合的交集并将结果存储在destination键中（同样以有序集合存储），**destination键中元素的分数是由AGGREGATE参数决定的。12345678910111213141516171819202122232425262728293031323334353637(1）当AGGREGATE是SUM时（也就是默认值），destination键中元素的分数是每个参与计算的集合中该元素分数的和。例如：- redis&gt; ZADD sortedSets1 1 a 2 b- (integer) 2- redis&gt; ZADD sortedSets2 10 a 20 b- (integer) 2- redis&gt; ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2- (integer) 2redis&gt; ZRANGE sortedSetsResult 0 -1 WITHSCORES- &quot;a&quot;- &quot;11&quot;- &quot;b&quot;- &quot;22&quot;（2）当AGGREGATE是MIN时，destination键中元素的分数是每个参与计算的集合中该元素分数的最小值。例如：redis&gt; ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 AGGREGATE MIN(integer) 2redis&gt; ZRANGE sortedSetsResult 0 -1 WITHSCORES1) &quot;a&quot;2) &quot;1&quot;3) &quot;b&quot;4) &quot;2&quot;（3）当AGGREGATE是MAX时，destination键中元素的分数是每个参与计算的集合中该元素分数的最大值。例如：redis&gt; ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 AGGREGATE MAX(integer) 2redis&gt; ZRANGE sortedSetsResult 0 -1 WITHSCORES1) &quot;a&quot;2) &quot;10&quot;3) &quot;b&quot;4) &quot;20&quot;ZINTERSTORE命令还能够通过WEIGHTS参数设置每个集合的权重，每个集合在参与计算时元素的分数会被乘上该集合的权重。例如：redis&gt; ZINTERSTORE sortedSetsResult 2 sortedSets1 sortedSets2 WEIGHTS 1 0.1(integer) 2redis&gt; ZRANGE sortedSetsResult 0 -1 WITHSCORES1) &quot;a&quot;2) &quot;2&quot;3) &quot;b&quot;4) &quot;4&quot;另外还有一个命令与ZINTERSTORE命令的用法一样，名为ZUNIONSTORE，它的作用是计算集合间的并集，这里不再赘述。 进阶1.事务（1）介绍redis中的事务是一组命令的集合。事务和命令一样都是redis的最小执行单位。redis中的错误类型分为两种： 语法错误：语法错误指命令不存在或者命令参数的人数不对。 运行错误：运行错误指在命令执行时出现的错误，比如乱用命令。 12345678910Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：批量操作在发送 EXEC 命令前被放入队列缓存。收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。一个事务从开始到执行会经历以下三个阶段：1.开始事务。2.命令入队。3.执行事务。 （2）命令 disard 取消事务，放弃执行事务块内的所有命令 exec 执行所有事务块内的命令 multi 开启事务 unwatch 取消watch命令对所有key的监视 watch key1 key2… 监视key1 key2等,watch监控对象之后，不能如果这个对象需要在事务内重新设值，那么这个对象不能在事务开启之前设值。如下：12345678910111213141516171819202122232425262728293031323334127.0.0.1:6379&gt; watch key1OK127.0.0.1:6379&gt; set key1 2OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set key1 3QUEUED127.0.0.1:6379&gt; exec(nil) // 错误，未执行设值127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set key1 2QUEUED127.0.0.1:6379&gt; exec1) OK127.0.0.1:6379&gt; set key1 4OK127.0.0.1:6379&gt; get key1&quot;4&quot;127.0.0.1:6379&gt; watch key1OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set key1 3QUEUED127.0.0.1:6379&gt; set key1 5QUEUED127.0.0.1:6379&gt; exec1) OK2) OK127.0.0.1:6379&gt; get key1&quot;5&quot;127.0.0.1:6379&gt; (3) 过期时间 expire key seconds 设置key多少秒后过期 返回1表示成功，0表示失败 ttl key 返回值表示过期剩余秒数，-1表示没有过期时间，-2表示键已删除或者键不存在 persist key 取消键的过期时间设置 1成功，0失败除了persist命令之外，使用set或getset命令为键赋值也同样会清除键的过期时间，其他只对键值进行操作的命令（如incr，lpush，hset，zrem）均不会影响键的过期时间 pexpire key milliseconds 设置key多少毫秒后过期 expireat key unixseconds 设置key的过期时间点，时间点为unix的时间格式，就是时间点到1970-01-01 00:00:00时间点的秒数 pexpireat key unixmillseconds (4) redis 实现缓存123456789当服务器内存有限时，如果大量地使用缓存键且过期时间设置得过长就会导致 Redis 占满内存；另一方面如果为了防止 Redis 占用内存过大而将缓存键的过期时间设得太短，就可能导致缓存命中率过低并且大量内存白白地闲置。实际开发中会发现很难为缓存键设置合理的过期时间，为此可以限制 Redis 能够使用的最大内存，并让Redis按照一定的规则淘汰不需要的缓存键，这种方式在只将Redis用作缓存系统时非常实用。具体的设置方法为：修改配置文件的maxmemory参数，限制Redis最大可用内存大小（单位是字节），当超出了这个限制时Redis会依据maxmemory-policy参数指定的策略来删除不需要的键直到Redis占用的内存小于指定内存。· noeviction：当内存使用达到阈值的时候，所有引起申请内存的命令会报错。· allkeys-lru：在主键空间中，优先移除最近未使用的key。· volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的key。· allkeys-random：在主键空间中，随机移除某个key。· volatile-random：在设置了过期时间的键空间中，随机移除某个key。· volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的key优先移除。 (4) 排序 sort key sort命令可以对集合，列表，有序集合进行排序，数据只能是数值类型,排序只依赖数值的大小 sort key alpha 通过alpha参数实现按照字典顺序排列非数字元素 sort key desc limit start index 参考mysql sort list by somekey:* desc sort list by somekey:*-&gt;item desc 参考自: 李子骅. “Redis入门指南（第2版）”。 redis并发问题]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java事物隔离级别]]></title>
    <url>%2F2018%2F01%2F16%2Fjava%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[形成原因： java多线程并发导致读取数据时出现了一些问题： 脏读:一个事务读取了另一个未提交的并行事务写的数据 不可重复读:一个事务重新读取前面读取过的数据， 发现该数据已经被另一个已提交的事务修改过 幻读:一个事务重新执行一个查询，返回一套符合查询条件的行， 发现这些行因为其他最近提交的事务而发生了改变 事物隔离级别 读未提交（Read uncommitted） 读已提交（Readcommitted） 可重复读（Repeatableread） 可串行化（Serializable） 隔离级别与问题对应关系]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring表达式语言]]></title>
    <url>%2F2018%2F01%2F07%2FSpring%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[Spring表达式语言:SpEL(一段简单的spel入门代码)代码代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.panjianguo.service;import org.springframework.expression.EvaluationContext;import org.springframework.expression.Expression;import org.springframework.expression.ExpressionParser;import org.springframework.expression.spel.standard.SpelExpressionParser;import org.springframework.expression.spel.support.StandardEvaluationContext;import java.lang.reflect.Method;/** * 一句话功能简述 */public class SpelTest &#123; public static void main(String[] args) throws NoSuchMethodException &#123; //创建解析器 ExpressionParser parser = new SpelExpressionParser(); //解析表达式 Expression expression = parser.parseExpression("#decorate('Hello '+#person.name+#end)"); //构造上下文 EvaluationContext context = new StandardEvaluationContext(); //为end参数值来赋值 context.setVariable("end", "!"); // 为对象赋值 Person person = new Person("小明", "男", 18); context.setVariable("person", person); // 为方法赋值 Method decorate = SpelTest.class.getDeclaredMethod("decorate", String.class); context.setVariable("decorate", decorate); //打印expression表达式的值 System.out.println(expression.getValue(context)); &#125; // 人员 static class Person &#123; private String name; private String gender; private Integer age; Person(String name, String gender, Integer age) &#123; this.name = name; this.gender = gender; this.age = age; &#125; public String getName() &#123; return name; &#125; &#125; // 修饰方法 static String decorate(String content) &#123; return "***"+content+"***"; &#125;&#125; 执行输出值1234/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/bin/java ...***Hello 小明!***Process finished with exit code 0 主要步骤1) 创建解析器2) 给解析器设置解析表达式3) 创建构造上下文4) 为构造上下文设置转化参数5) 解析器通过构造上下文将解析表达式转化成想要的内容（在SpEL表达式中，默认情况下，表达式前缀为 ‘ # ‘ ，而后缀为 ‘ } ‘ 。如果表达式中没有前缀和后缀，那么表达式字符串就被当作纯文本。）]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
