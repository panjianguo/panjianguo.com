<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[docker使用]]></title>
    <url>%2F2018%2F09%2F03%2Fdocker%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[docker 简介Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）。几乎没有性能开销，可以很容易地在机器和数据中心中运行。最重要的是，他们不依赖于任何语言、框架包括系统。 一、CentOS6.x安装docker1) 更新yum源1yum update -y 2) 通过安装docker-io软件包来安装Docker1yum -y install docker-io 3) 启动docker进程1service docker on 4) 让docker在服务器启动时启动1chkconfig docker on 二、Docker 使用1） 查询和拉取镜像 12docker search mysql:5.7docker pull mysql:5.7 2) 列出镜像 1234[root@vultr /]# docker imagesREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEhub.c.163.com/library/mysql 5.7 573ca163b053 11 months ago 407.1 MBmysql 5.7 573ca163b053 11 months ago 407.1 MB 3) 运行docker 1234567docker run -d -p 3306:3306 --name mymysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7-d 表示后台云信docker镜像-p 表示端口号，前一个8080是指我们访问tomcat时的端口号，后一个8080是tomcat启动的一个容器在docker中运行的端口号，指定端口号为了更明确的访问tomcat。 tomcat:last last是指定的tomcat的标签，相同的镜像可以指定不同的标签以做区分。 4) 列出正在运行的容器 123[root@vultr /]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES94ee2b979517 mysql:5.7 &quot;docker-entrypoint.s 2 days ago Up 2 days 0.0.0.0:3306-&gt;3306/tcp mysqlserver 5) 进入容器1docker exec -it 94ee2b979517 /bin/bash 6) 停止运行容器 1docker stop 44d9be4dca95 7) 移除容器和移除镜像12docker rm 44d9be4dca95 // 移除容器docker rmi 4b8387148088 // 移除镜像 三、docker 安装mysql1.下载镜像，mysql 5.71docker pull mysql:5.7 2.创建mysql容器，并后台启动1docker run -d -p 3306:3306 -e MYSQL_USER=&quot;woniu&quot; -e MYSQL_PASSWORD=&quot;123456&quot; -e MYSQL_ROOT_PASSWORD=&quot;123456&quot; --name mysqltest1 mysql:5.7 --character-set-server=utf8 --collation-server=utf8_general_ci 参数说明：-e MYSQL_USER=”root” ：添加root用户 -e MYSQL_PASSWORD=”123456”：设置添加的用户密码 -e MYSQL_ROOT_PASSWORD=”123456”：设置root用户密码 –character-set-server=utf8：设置字符集为utf8 –collation-server=utf8_general_cli：设置字符比较规则为utf8_general_cli 3.挂载外部配置和数据安装1) 创建目录和配置文件my.cnf1234567891011121314151617mkdir /dockermkdir /docker/mysqlmkdir /docker/mysql/confmkdir /docker/mysql/data 创建my.cnf配置文件touch /docker/mysql/conf/my.cnf my.cnf添加如下内容：[mysqld]user=mysqlcharacter-set-server=utf8default_authentication_plugin=mysql_native_password[client]default-character-set=utf8[mysql]default-character-set=utf8 2) 创建容器，并后台启动 1docker run -d -p 3306:3306 --privileged=true -v /docker/mysql/conf/my.cnf:/etc/my.cnf -v /docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysqltest2 mysql:5.7 参数说明： –privileged=true：容器内的root拥有真正root权限，否则容器内root只是外部普通用户权限 -v /docker/mysql/conf/my.cnf:/etc/my.cnf：映射配置文件 -v /docker/mysql/data:/var/lib/mysql：映射数据目录]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2018%2F05%2F02%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[IOC容器IOC(Inverse of Control) 控制反转对于软件来说，某一接口具体实现类的选择控制权从调用类中移除，转交给第三方决定。IOC也被叫做依赖注入， 类装载器 ClassLoader类装载器就是寻找类的字节码文件并狗仔出类在JVM内部表示的对象组件。在java中，类装载器吧一个类装入jvm中，要经过一下步骤：1) 装载2) 连接3) 初始化 三个转载器： ClassLoader 根装载器，C语言编写 ExtClassLoader 扩展类装载器 AppClassLoader 系统类扩展器，负责装载Classpath路径下的类包获取类装载器：1ClassLoader loader = Thread.currentThread().getContextClassLoader(); java中无论某个类生成多少个对象，这些对象都对应于同一个Class对象 反射都是再程序进行时，不是编译的时候 1) 获取类加载器1ClassLoader loader = Thread.currentThread().getContextClassLoader(); 2) 获取类类型12Class SampleClass = loader.loadClass(&quot;com.panjianguo.service.SampleClass&quot;);// Class SampleClass = Class.fromName(&quot;com.panjianguo.service.SampleClass&quot;); 下面的方法实际上是Class封装的方法，实际上都是先获取当前线程的类加载器，然后类加载器通过类的全限定名获取到类的类型对象3) 获取类的构造函数反射类1Constructor declaredConstructor = SampleClass.getDeclaredConstructor(); 4) 通过构造函数反射类创建对象12com.panjianguo.service.SampleClass sample = (SampleClass) declaredConstructor.newInstance();// com.panjianguo.service.SampleClass sampleClass1 = (SampleClass) SampleClass.newInstance(); 下面通过类名直接调用newInstance方法实际上也是调用了反射构造函数的newInstance方法，从而创建了对应类的对象5) 获取类的方法反射类1Method setName = SampleClass.getMethod(&quot;setName&quot;, String.class); 6) 方法调用1setName.invoke(sampleClass, &quot;小明&quot;);]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2F2018%2F02%2F05%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[迭代器模式1.迭代器是什么？迭代器是一个对象，它的工作是遍历并选择序列中的对象，它提供了一种访问一个容器对象中的各个元素，而又不必暴露该对象内部细节的方法。 2.容器是什么？在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体 3.我们接触过哪些容器，都是干什么用的？ tomcat容器 如果web服务器应用得到一个指向某个servlet的请求，此时服务器不是把servlet交给servlet本身，而是交给部署该servlet的容器。要有容器向servlet提供http请求和响应，而且要由容器调用servlet的方法，如doPost或者doGet。 spring容器 Spring容器就是一个巨大的工厂。Spring容器使用Ioc管理所有组成应用系统的组件，用来管理bean的生命周期 springMVC容器 是Spring的子容器 4.迭代器案例：书架和书1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 书public class Book &#123; private String name; public Book(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;// 书架public class BookShelf &#123; private Book[] books; private int last = 0; public BookShelf(int maxsize) &#123; this.books = new Book[maxsize]; &#125; public Book getBookAt(int index) &#123; return books[index]; &#125; public void appendBook(Book book) &#123; this.books[last] = book; last++; &#125; public int getLength() &#123; return last; &#125; // 后期放入 public BookShelfIterator getIterator() &#123; return new BookShelfIterator(this); &#125;&#125;// 迭代器接口public interface Iterator &#123; public abstract boolean hasNext(); public abstract Object next();&#125;// 书架迭代器public class BookShelfIterator implements Iterator &#123; private BookShelf bookShelf; private int index; public BookShelfIterator(BookShelf bookShelf) &#123; this.bookShelf = bookShelf; this.index = 0; &#125; @Override public boolean hasNext() &#123; if (index &lt; bookShelf.getLength()) &#123; return true; &#125; return false; &#125; @Override public Object next() &#123; Book book = bookShelf.getBookAt(index); index++; return book; &#125;&#125; 实现步骤：1) 创建书本和书架类2) 定义迭代器接口3) 创建书本迭代器，需要实现hasNext()方法和next()方法4) 在书架中添加getLength()和getBookAt()的方法为实现hasnext()和next()接口提供服务5) 再书架中添加自身迭代器的方法getIterator() 5.原理总结对于迭代器模式总的来说都是相对于集合来说的，主要是用于获取集合自身的元素。可以先定义元素类和集合类，比如书和书架，定义集合的迭代器，可以定义在外部类也可以定义为集合的内部类。获取到自身的迭代器之后就可以从迭代器中逐个获取集合中的元素了。 6.ArrayList和hashMap如何获取迭代器？ArrayList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172*/ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; HashMap1234567891011121314151617181920212223242526final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; 个人总结：感觉iterator的实现都用到了数组]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis学习笔记]]></title>
    <url>%2F2018%2F01%2F18%2Fredis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、 redis简介redis是什么？ redis是REmote Dictionary Server(远程字典服务器)的缩写，它以字典结构存储数据，并允许其他应用通过TCP协议读取字典中的内容。Redis是一个开源的、高性能的、基于键值对的缓存与存储系统，通过提供多种键值数据类型来适应不同场景下的缓存与存储需求。同时 Redis 的诸多高层级功能使其可以胜任消息队列、任务队列等不同的角色。 redis有哪些特性1) redis通过键值对的方式存储，键值数据类型如下： 字符串类型 散列类型 列表类型 集合类型 有序集合类型2) 内存存储与持久化，redis的数据都存储在内存中，对于硬盘存储存在明显的速度优势。程序退出后内存中的数据会丢失,但是Redis提供了对持久化的支持，即可以将内存中的数据异步写入到硬盘中，同时不影响继续提供服务。3) 功能丰富4) 简单稳定。redis有100多个命令，但常用的就十几个，redis用C语言编写，并且开源。 二、redis安装mac 安装redis1) brew install redis2) 安装目录：/usr/local/Cellar/redis/3.2.83) 添加至开机启动项12$ ln -f /usr/local/Cellar/redis/2.8.13/homebrew.mxcl.redis.plist ~/Library/LaunchAgents/$ launchctl load ~/Library/LaunchAgents/homebrew.mxcl.redis.plist 4) 启动redis 启动 redis-server5) redis默认端口及配置文件 REDISPORT=6379 EXEC=/usr/local/bin/redis-server CLIEXEC=/usr/local/bin/redis-cli PIDFILE=/var/run/redis_${REDISPORT}.pid CONF=/etc/redis/${REDISPORT}.conf6) 关闭redis 关闭redis redis-cli shutdown 或者 kill redis 三、redis通用命令redis命令1) redis-cli -h 127.0.0.1 -p 63792) redis-cli PING3) redis-cli 不带参数进入redis交互模式4) 配置redis日志级别 redis-server /path/to/redis.conf –loglevel warning redis&gt; CONFIG SET loglevel warning 取值与赋值1) set key value2) get key3) incr key 递增数字 DECR key 减少数字（下面的递增递减省略）4) incrby key integer 增加指定的整数5) incrbyfloat key float 增加指定的双精度浮点数6) append key value 向尾部追加值7) strlen key 获取字符串长度8) mset key1 value1 key2 value2 … 设置多个键值对9) mget key1 key2 … 根据多个键值对获取多个值10) 位操作：（感觉不常用） GETBIT key offset GETBIT命令可以获得一个字符串类型键指定位置的二进制位的值（0或1），索引从0开始，如果需要获取的二进制位的索引超出了键值的二进制位的实际长度则默认位值是0 SETBIT key offset value SETBIT 命令可以设置字符串类型键指定位置的二进制位的值，返回值是该位置的旧值，如果要设置的位置超过了键值的二进制位的长度，SETBIT命令会自动将中间的二进制位设置为0，同理设置一个不存在的键的指定二进制位的值会自动将其前面的位赋值为0 BITCOUNT key [start] [end] BITCOUNT命令可以获得字符串类型键中值是1的二进制位个数可以通过参数来限制统计的字节范围 BITOP operation destkey key [key …] BITOP命令可以对多个字符串类型键进行位运算，并将结果存储在destkey参数指定的键中。BITOP命令支持的运算操作有AND、OR、XOR和NOT redis类型1.散列类型（1）介绍 Redis 是采用字典结构以键值对的形式存储数据的，而散列类型（hash）的键值也是一种字典结构，其存储了字段（field）和字段值的映射，但字段值只能是字符串，不支持其他数据类型，换句话说，散列类型不能嵌套其他的数据类型。一个散列类型键可以包含至多232−1个字段。 提示 除了散列类型，Redis 的其他数据类型同样不支持数据类型嵌套。比如集合类型的每个元素都只能是字符串，不能是另一个集合或散列表等。 散列类型适合存储对象：使用对象类别和 ID 构成键名，使用字段表示对象的属性，而字段值则存储属性值。 （2）命令1) HSET key field value2) HGET key field3) HMSET key field value [field value …]4) HMGET key field [field …]5) HGETALL key6) HEXISTS key field 判断字段是否存在7) HSETNX key field value 当前字段不存在时赋值8) HINCRBY key field increment 增加数字9) HDEL key field [field …] 删除字段10) HKEYS key 只获取对象的所有字段名11) HVALUES key 只获取对象的所有字段值 参考自 李子骅. “Redis入门指南（第2版）”。]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java事物隔离级别]]></title>
    <url>%2F2018%2F01%2F16%2Fjava%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[形成原因： java多线程并发导致读取数据时出现了一些问题： 脏读:一个事务读取了另一个未提交的并行事务写的数据 不可重复读:一个事务重新读取前面读取过的数据， 发现该数据已经被另一个已提交的事务修改过 幻读:一个事务重新执行一个查询，返回一套符合查询条件的行， 发现这些行因为其他最近提交的事务而发生了改变 事物隔离级别 读未提交（Read uncommitted） 读已提交（Readcommitted） 可重复读（Repeatableread） 可串行化（Serializable） 隔离级别与问题对应关系]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring表达式语言]]></title>
    <url>%2F2018%2F01%2F07%2FSpring%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[Spring表达式语言:SpEL(一段简单的spel入门代码)代码代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.panjianguo.service;import org.springframework.expression.EvaluationContext;import org.springframework.expression.Expression;import org.springframework.expression.ExpressionParser;import org.springframework.expression.spel.standard.SpelExpressionParser;import org.springframework.expression.spel.support.StandardEvaluationContext;import java.lang.reflect.Method;/** * 一句话功能简述 */public class SpelTest &#123; public static void main(String[] args) throws NoSuchMethodException &#123; //创建解析器 ExpressionParser parser = new SpelExpressionParser(); //解析表达式 Expression expression = parser.parseExpression("#decorate('Hello '+#person.name+#end)"); //构造上下文 EvaluationContext context = new StandardEvaluationContext(); //为end参数值来赋值 context.setVariable("end", "!"); // 为对象赋值 Person person = new Person("小明", "男", 18); context.setVariable("person", person); // 为方法赋值 Method decorate = SpelTest.class.getDeclaredMethod("decorate", String.class); context.setVariable("decorate", decorate); //打印expression表达式的值 System.out.println(expression.getValue(context)); &#125; // 人员 static class Person &#123; private String name; private String gender; private Integer age; Person(String name, String gender, Integer age) &#123; this.name = name; this.gender = gender; this.age = age; &#125; public String getName() &#123; return name; &#125; &#125; // 修饰方法 static String decorate(String content) &#123; return "***"+content+"***"; &#125;&#125; 执行输出值1234/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/bin/java ...***Hello 小明!***Process finished with exit code 0 主要步骤1) 创建解析器2) 给解析器设置解析表达式3) 创建构造上下文4) 为构造上下文设置转化参数5) 解析器通过构造上下文将解析表达式转化成想要的内容（在SpEL表达式中，默认情况下，表达式前缀为 ‘ # ‘ ，而后缀为 ‘ } ‘ 。如果表达式中没有前缀和后缀，那么表达式字符串就被当作纯文本。）]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
