<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>曾经的自己</title>
  
  <subtitle>光明给我们经验，读书给我们知识</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-16T12:28:17.147Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>农纷期第一李白</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://yoursite.com/2018/09/16/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/16/工厂模式/</id>
    <published>2018-09-16T12:26:39.000Z</published>
    <updated>2018-09-16T12:28:17.147Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、工厂模式简介&quot;&gt;&lt;a href=&quot;#一、工厂模式简介&quot; class=&quot;headerlink&quot; title=&quot;一、工厂模式简介&quot;&gt;&lt;/a&gt;一、工厂模式简介&lt;/h2&gt;&lt;p&gt;工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;/p&gt;
&lt;p&gt;工厂模式是指对象的创建不是外部对象直接调用对象的构造函数创建对象，而是调用该对象对应的工厂类对象去创建对应的类对象。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>建造者(builder)模式</title>
    <link href="http://yoursite.com/2018/09/07/%E5%BB%BA%E9%80%A0%E8%80%85-builder-%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/07/建造者-builder-模式/</id>
    <published>2018-09-07T02:19:21.000Z</published>
    <updated>2018-09-07T02:23:30.694Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;建造模式是对象的创建模式。建造模式可以将一个产品的内部表象（internal representation）与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>转载：学习一下德国人民的翻墙精神</title>
    <link href="http://yoursite.com/2018/09/06/%E7%BF%BB%E5%A2%99/"/>
    <id>http://yoursite.com/2018/09/06/翻墙/</id>
    <published>2018-09-06T05:58:24.000Z</published>
    <updated>2018-09-06T06:08:06.656Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近常听到有人抱怨翻墙太麻烦，俺心里就嘀咕：你要是知道当年德国人民翻墙的艰辛和危险，或许就不会再抱怨翻 GFW 这堵墙的麻烦了。说到德国人的翻墙，比较关心政治的同学应该会联想到大名鼎鼎的 柏林墙。从某种意义上看，东德共党在 60 年代建造的柏林墙和中国共党在 21 世纪架设的 GFW 真是具有异曲同工之妙——两堵『墙』都是用来阻止本国人民对自由的追求。各位同学们目前的处境，和当年东德老百姓的处境也很类似——都在挖空心思琢磨 翻墙之术。&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="http://yoursite.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://yoursite.com/2018/09/06/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/09/06/观察者模式/</id>
    <published>2018-09-06T03:08:49.000Z</published>
    <updated>2018-09-06T03:15:07.204Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、模式动机&quot;&gt;&lt;a href=&quot;#一、模式动机&quot; class=&quot;headerlink&quot; title=&quot;一、模式动机&quot;&gt;&lt;/a&gt;一、模式动机&lt;/h2&gt;&lt;p&gt;建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>动态代理</title>
    <link href="http://yoursite.com/2018/09/05/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2018/09/05/动态代理/</id>
    <published>2018-09-05T09:10:14.000Z</published>
    <updated>2018-09-05T09:29:21.916Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态代理&quot;&gt;&lt;a href=&quot;#动态代理&quot; class=&quot;headerlink&quot; title=&quot;动态代理&quot;&gt;&lt;/a&gt;动态代理&lt;/h1&gt;&lt;p&gt;动态代理：在程序运行时，通过反射机制动态地创建一个代理类。&lt;/p&gt;
&lt;h2 id=&quot;模式要点分析&quot;&gt;&lt;a href=&quot;#模式要点分析&quot; class=&quot;headerlink&quot; title=&quot;模式要点分析&quot;&gt;&lt;/a&gt;模式要点分析&lt;/h2&gt;&lt;p&gt;1) 动态的体现：程序开始执行时是没有代理类的，在程序运行时，java利用反射机制动态生成代理类的实例&lt;br&gt;2) jdk技术支持：java在java.lang.reflect包里提供两个类/接口帮助我们创建和使用代理类实例，一个是Proxy类，一个是InvocationHandler接口。&lt;br&gt;3) 两种代理类的模式区别：静态模式要求为程序中所有需要被访问的目标创建代理类，如果有10种代理目标，我们就得创建10个代理类，让代理类直接访问目标对象。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>静态代理</title>
    <link href="http://yoursite.com/2018/09/04/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2018/09/04/静态代理/</id>
    <published>2018-09-04T09:58:08.000Z</published>
    <updated>2018-09-04T09:59:39.795Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java-静态代理&quot;&gt;&lt;a href=&quot;#java-静态代理&quot; class=&quot;headerlink&quot; title=&quot;java 静态代理&quot;&gt;&lt;/a&gt;java 静态代理&lt;/h1&gt;&lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h3&gt;&lt;p&gt;为其他对象提供一种代理以控制对这个对象的访问称为代理。&lt;/p&gt;
&lt;h4 id=&quot;定义要点：&quot;&gt;&lt;a href=&quot;#定义要点：&quot; class=&quot;headerlink&quot; title=&quot;定义要点：&quot;&gt;&lt;/a&gt;定义要点：&lt;/h4&gt;&lt;p&gt;1) 其他对象：目标对象，想要访问的对象，常被称为被委托对象或被代理对象。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>docker使用</title>
    <link href="http://yoursite.com/2018/09/03/docker%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/09/03/docker使用/</id>
    <published>2018-09-03T07:30:32.000Z</published>
    <updated>2018-09-03T08:49:59.753Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;docker-简介&quot;&gt;&lt;a href=&quot;#docker-简介&quot; class=&quot;headerlink&quot; title=&quot;docker 简介&quot;&gt;&lt;/a&gt;docker 简介&lt;/h1&gt;&lt;p&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）。几乎没有性能开销，可以很容易地在机器和数据中心中运行。最重要的是，他们不依赖于任何语言、框架包括系统。&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="http://yoursite.com/2018/05/02/%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2018/05/02/反射/</id>
    <published>2018-05-02T06:01:01.000Z</published>
    <updated>2018-09-07T02:56:36.560Z</updated>
    
    <summary type="html">
    
      &lt;h5 id=&quot;IOC容器&quot;&gt;&lt;a href=&quot;#IOC容器&quot; class=&quot;headerlink&quot; title=&quot;IOC容器&quot;&gt;&lt;/a&gt;IOC容器&lt;/h5&gt;&lt;h6 id=&quot;IOC-Inverse-of-Control-控制反转&quot;&gt;&lt;a href=&quot;#IOC-Inverse-of-Control-控制反转&quot; class=&quot;headerlink&quot; title=&quot;IOC(Inverse of Control) 控制反转&quot;&gt;&lt;/a&gt;IOC(Inverse of Control) 控制反转&lt;/h6&gt;&lt;p&gt;对于软件来说，某一接口具体实现类的选择控制权从调用类中移除，转交给第三方决定。IOC也被叫做依赖注入，&lt;/p&gt;
&lt;h6 id=&quot;类装载器-ClassLoader&quot;&gt;&lt;a href=&quot;#类装载器-ClassLoader&quot; class=&quot;headerlink&quot; title=&quot;类装载器 ClassLoader&quot;&gt;&lt;/a&gt;类装载器 ClassLoader&lt;/h6&gt;&lt;p&gt;类装载器就是寻找类的字节码文件并狗仔出类在JVM内部表示的对象组件。&lt;br&gt;在java中，类装载器吧一个类装入jvm中，要经过一下步骤：&lt;br&gt;1) 装载&lt;br&gt;2) 连接&lt;br&gt;3) 初始化&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="http://yoursite.com/2018/02/05/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/02/05/迭代器模式/</id>
    <published>2018-02-05T12:25:44.000Z</published>
    <updated>2018-09-06T05:35:26.515Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;迭代器模式&quot;&gt;&lt;a href=&quot;#迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式&quot;&gt;&lt;/a&gt;迭代器模式&lt;/h2&gt;&lt;h3 id=&quot;1-迭代器是什么？&quot;&gt;&lt;a href=&quot;#1-迭代器是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.迭代器是什么？&quot;&gt;&lt;/a&gt;1.迭代器是什么？&lt;/h3&gt;&lt;p&gt;迭代器是一个对象，它的工作是遍历并选择序列中的对象，它提供了一种访问一个容器对象中的各个元素，而又不必暴露该对象内部细节的方法。&lt;/p&gt;
&lt;h3 id=&quot;2-容器是什么？&quot;&gt;&lt;a href=&quot;#2-容器是什么？&quot; class=&quot;headerlink&quot; title=&quot;2.容器是什么？&quot;&gt;&lt;/a&gt;2.容器是什么？&lt;/h3&gt;&lt;p&gt;在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体&lt;/p&gt;
&lt;h3 id=&quot;3-我们接触过哪些容器，都是干什么用的？&quot;&gt;&lt;a href=&quot;#3-我们接触过哪些容器，都是干什么用的？&quot; class=&quot;headerlink&quot; title=&quot;3.我们接触过哪些容器，都是干什么用的？&quot;&gt;&lt;/a&gt;3.我们接触过哪些容器，都是干什么用的？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;tomcat容器 如果web服务器应用得到一个指向某个servlet的请求，此时服务器不是把servlet交给servlet本身，而是交给部署该servlet的容器。要有容器向servlet提供http请求和响应，而且要由容器调用servlet的方法，如doPost或者doGet。&lt;/li&gt;
&lt;li&gt;spring容器 Spring容器就是一个巨大的工厂。Spring容器使用Ioc管理所有组成应用系统的组件，用来管理bean的生命周期&lt;/li&gt;
&lt;li&gt;springMVC容器 是Spring的子容器&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>redis学习笔记</title>
    <link href="http://yoursite.com/2018/01/18/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/18/redis学习笔记/</id>
    <published>2018-01-18T03:10:33.000Z</published>
    <updated>2018-09-04T02:59:58.902Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、-redis简介&quot;&gt;&lt;a href=&quot;#一、-redis简介&quot; class=&quot;headerlink&quot; title=&quot;一、 redis简介&quot;&gt;&lt;/a&gt;一、 redis简介&lt;/h1&gt;&lt;h2 id=&quot;redis是什么？&quot;&gt;&lt;a href=&quot;#redis是什么？&quot; class=&quot;headerlink&quot; title=&quot;redis是什么？&quot;&gt;&lt;/a&gt;redis是什么？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;redis是REmote Dictionary Server(远程字典服务器)的缩写，它以字典结构存储数据，并允许其他应用通过TCP协议读取字典中的内容。&lt;br&gt;Redis是一个开源的、高性能的、基于键值对的缓存与存储系统，通过提供多种键值数据类型来适应不同场景下的缓存与存储需求。同时 Redis 的诸多高层级功能使其可以胜任消息队列、任务队列等不同的角色。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>java事物隔离级别</title>
    <link href="http://yoursite.com/2018/01/16/java%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2018/01/16/java事物隔离级别/</id>
    <published>2018-01-16T13:29:54.000Z</published>
    <updated>2018-09-03T08:50:21.856Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;形成原因：&quot;&gt;&lt;a href=&quot;#形成原因：&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring表达式语言</title>
    <link href="http://yoursite.com/2018/01/07/Spring%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2018/01/07/Spring表达式语言/</id>
    <published>2018-01-07T12:08:48.000Z</published>
    <updated>2018-09-04T03:22:15.621Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring表达式语言-SpEL-一段简单的spel入门代码&quot;&gt;&lt;a href=&quot;#Spring表达式语言-SpEL-一段简单的spel入门代码&quot; class=&quot;headerlink&quot; title=&quot;Spring表达式语言:SpEL(一段简单的spel入门代码)&quot;&gt;&lt;/a&gt;Spring表达式语言:SpEL(一段简单的spel入门代码)&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Spring表达式语言（简称SpEl）是一个支持查询和操作运行时对象导航图功能的强大的表达式语言. 它的语法类似于传统EL，但提供额外的功能，最出色的就是函数调用和简单字符串的模板函数。&lt;/p&gt;
&lt;p&gt;尽管有其他可选的 Java 表达式语言，如 OGNL, MVEL,JBoss EL 等等，但 Spel 创建的初衷是了给 Spring 社区提供一种简单而高效的表达式语言，一种可贯穿整个 Spring 产品组的语言。这种语言的特性应基于 Spring 产品的需求而设计。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
</feed>
